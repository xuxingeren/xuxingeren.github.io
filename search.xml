<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[特效篇--图片环绕]]></title>
    <url>%2F2017%2F12%2F30%2Fsurround%2F</url>
    <content type="text"><![CDATA[2017年快要结束了，来点特效的东西作为2017年博客的结束篇吧，其实特效这东西看看就好了，实际用处不是特别的大，不过效果什么的还是挺酷的。 本文介绍的是图片环绕，散列切换如何完成的，一共三个切换效果，先看看效果吧：当然博客展示的面积不够：请点这里查看全部效果链接。废话不多说直接上代码了：html：1234567891011121314151617181920212223242526&lt;div class="btnbox"&gt; &lt;button class="show btn"&gt;散列&lt;/button&gt; &lt;button class="btn"&gt;横环装&lt;/button&gt; &lt;button class="btn"&gt;竖环装&lt;/button&gt; &lt;div class="pox"&gt;&lt;label for="change"&gt;自动播放：&lt;/label&gt;&lt;input id="change" type="checkbox"/&gt; &amp;nbsp;速度：&lt;input type="range" value="4" max="10" min="1" id="speed" value="1"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="wrap" id="wrap"&gt; &lt;!-- //photo平移旋转 &lt;div class="photo photo-front""&gt; //photo-wrap负责翻转 &lt;div class="photo-wrap"&gt; &lt;div class="side side-front"&gt; &lt;p class="imgs"&gt;&lt;img src=""/&gt;&lt;/p&gt; &lt;p class="caption"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="side side-back"&gt; &lt;p class="desc"&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; --&gt;&lt;/div&gt; html还是挺简单的，btnbox就是控制图片排列和轮播的控制台，#wrap就是我们的放置容器了，注释的代码是大致的样式，我们用两层div包裹住文字和图片，第一层div(.photo)，这个是负责整个块的移动的，第二层div(.photo-wrap)是负责自身的前后两面翻转的，.side-front负责前面的图片和文字显示，.side-back负责背面的文字显示，由于所有的图片内容都是根据一个json生成的，所以这里#wrap里面所有的内容都是通过js生成的，#wrap实际上不用放任何东西。css：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 .wrap &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, 0.8); overflow: hidden; perspective: 1800px;&#125;.photo &#123; width: 260px; height: 320px; position: absolute; z-index: 1; box-shadow: 0 0 1px rgba(0, 0, 0, 0.01); transition: all 0.5s; left: 50%; top: 50%; margin: -160px 0 0 -130px;&#125;.photo .side &#123; width: 100%; height: 100%; background: #eee; position: absolute; right: 0; top: 0; padding: 20px; box-sizing: border-box; backface-visibility: hidden;&#125;.photo .side-front &#123; transform: rotateY(0deg);&#125;.side-back &#123; transform: rotateY(180deg);&#125;/*当前选中样式*/ .photo-center &#123; left: 50%; top: 50%; margin: -160px 0 0 -130px; z-index: 999;&#125;.photo-wrap &#123; width: 100%; height: 100%; position: absolute; transform-style: preserve-3d; transition: all 0.5s; transform-origin: 0;&#125;.photo-front .photo-wrap &#123; transform: rotateY(0deg) translate(0px, 0px);&#125;.photo-back .photo-wrap &#123; transform: rotateY(180deg) translate(-260px, 0px);&#125; css算是比较复杂吧，主要是涉及css3的内容太多了，不熟悉的去充充电吧，这里只列出了一部分css，稍微讲解一下，基础的就不说了。正反翻转：.side是反面和正面的共同属性,.side-front是正面所以transform: rotateY(0deg);旋转了0度正对屏幕，.side-back是背面用transform: rotateY(180deg);旋转180度，背面对着屏幕，其中用到了backface-visibility: hidden;这个属性，这个属性让不面向屏幕的旋转元素背面影藏掉，即.side-back隐藏掉了，当翻转.photo-wrap时，.side-front就隐藏了，这就让.photo-wrap看起来就像真的有两面一样。原地翻转动画：.photo-wrap沿着Y轴旋转时我们要让其沿着左边进行180度旋转，所以transform-origin的x轴一定要为0，旋转后.photo-wrap就向左边移动了它本身的宽度的距离，简单来说就像翻书一样，一页翻过去了就相当于移动了一页的距离。我们要让其原地翻转就要对其x轴的translate进行设置，让其向右边移动它本身的宽度的距离，所以设置translate(-260px, 0px)，这样就相当于它没有进行移动了,看起来就像原地翻转一样。 比较难以理解的css就是这些了，开始正式写了。工欲善其事必先利其器，首先我们先准备好要渲染的数据，组合一个json，复杂的东西懒得写，就写点简简单单的吧，放40张图片吧：12345678910111213141516171819202122232425function data() &#123; var data = []; for (var i = 1; i &lt; 41; i++) &#123; data.push(&#123; img: './waterfall/images/' + i + '.jpg', caption: '第' + texthan(i) + '张', desc: '描述' + texthan(i) &#125;); &#125;; return data;&#125;;function texthan(n) &#123; var han = ['一', '二', '三', '四', '五', '六', '七', '八', '九', '十']; if (n &gt; 10) &#123; var s = Math.floor(n / 10) &gt; 1 ? han[Math.floor(n / 10) - 1] : '十'; var g = n % 10 - 1 &gt;= 0 ? han[n % 10 - 1] : '十'; return s + g; &#125; else &#123; return han[n - 1]; &#125;&#125;//其实大致就是下面这个json，img为图片地址，caption是第几张图，desc是图片描述[&#123;img: "./waterfall/images/1.jpg", caption: "第一张", desc: "描述一"&#125;,&#123;img: "./waterfall/images/2.jpg", caption: "第二张", desc: "描述二"&#125;,&#123;img: "./waterfall/images/3.jpg", caption: "第三张", desc: "描述三"&#125;] 好了，图片准备好了，开始写函数了，其他的东西懒得配置了，就俩个配置项，activeindex是当前选中的图片索引，state是轮播的类型：12345function Surround(option) &#123; option = option || &#123;&#125;; this.activeindex = option.activeindex || 0; this.state = option.state || 0;&#125; 老规矩，先来几个工具函数：1234567891011121314151617181920212223Surround.prototype = &#123; getdom: function (obj) &#123; var method = obj.substr(0, 1) == '.' ? 'getElementsByClassName' : 'getElementById'; return document[method](obj.substr(1)); &#125;, getwh: function (obj) &#123; return &#123; w: obj.clientWidth, h: obj.clientHeight &#125; &#125;, select: function (start, end) &#123; var num = end - start + 1; return Math.floor(Math.random() * num + start); &#125;, time:function(data) &#123; if (this.activeindex &gt; data.length - 1) &#123; this.activeindex = 0; &#125;; this.rsort(this.activeindex); this.activeindex++; &#125;&#125; getdom用于获取节点，getwh返回传入dom的宽高集合，select返回传入最大数和最小数之间的随机数，time负责轮播的切换。其实轮播的原理很简单，从.photo中选出一个放在中间，其余的通过随机数给生成随机的top和left以及旋转角度，，点击中间的，调用的是翻转函数，点击其他的则把你点击的放中间，其他的再随机生成。移动动画什么的交给css3的transition完成。原理说了，下面开始生成图片了，注下面的函数全写在Surround.prototype里的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546addPhotos: function (data) &#123; var lists = ''; var nav = ''; var navbox = document.createElement('div'); navbox.className = 'nav'; for (var i in data) &#123; var photobox = `&lt;div class="photo photo-front" id="photo_$&#123;i&#125;"&gt; &lt;div class="photo-wrap"&gt; &lt;div class="side side-front"&gt; &lt;p class="imgs"&gt; &lt;img src="$&#123;data[i].img&#125;" /&gt; &lt;/p&gt; &lt;p class="caption"&gt;$&#123;data[i].caption&#125;&lt;/p&gt; &lt;/div&gt; &lt;div class="side side-back"&gt; &lt;p class="desc"&gt; $&#123;data[i].desc&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;`; var navitem = `&lt;span id="nav_$&#123;i&#125;" class="i"&gt;&lt;/span&gt;` nav += navitem; lists += photobox; &#125; navbox.innerHTML = nav; this.getdom('#wrap').innerHTML = lists; this.getdom("#wrap").append(navbox); var i = this.getdom(".nav")[0].getElementsByClassName('i'); var photo = this.getdom(".photo"); [].slice.call(i).forEach(function(el,index) &#123; el.onclick = function()&#123; this.turn(this.getdom('#photo_'+index)); &#125;.bind(this); &#125;,this); [].slice.call(photo).forEach(function(el,index)&#123; el.onclick = function(event)&#123; this.turn(event.currentTarget); &#125;.bind(this); &#125;,this); this.rsort(this.activeindex);&#125; 我们先通过遍历data这个json创建出同数量的.photo和分页器.nav，然后分别给其添加点击事件调用turn()函数，然后调用rsort()函数传入this.activeindex，获得当前居中的索引。12345678910111213141516turn: function (elem) &#123; var cls = elem.className; var n = elem.id.split('_')[1]; this.activeindex = Number(n); if (!elem.classList.contains("photo-center")) &#123; return this.rsort(n); &#125; if (elem.classList.contains('photo-front')) &#123; cls = cls.replace(/photo-front/, "photo-back"); this.getdom("#nav_" + n).classList.add('i_back'); &#125; else &#123; cls = cls.replace(/photo-back/, "photo-front"); this.getdom("#nav_" + n).classList.remove('i_back'); &#125;; return elem.className = cls;&#125; turn()函数其实就是翻转函数，它根据传入函数的class判断是不是居中的.photo，是的话通过添加和移除class进行翻转，否者把this.activeindex改变为你点击的索引，调用rsort()函数传入this.activeindex。下面是主要的变化函数了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 rsort: function (n) &#123; var _photo = this.getdom('.photo'); var wrap = this.getwh(this.getdom('#wrap')); var photo = this.getwh(this.getdom('.photo')[0]); var photos = [] for (var i = 0; i &lt; _photo.length; i++) &#123; _photo[i].className = 'photo photo-front'; _photo[i].style.left = ''; _photo[i].style.top = ''; _photo[i].style['transform'] = 'rotate(0deg) scale(1.3)'; photos.push(_photo[i]); &#125;; var photo_center = this.getdom('#photo_' + n); photo_center.className += ' photo-center'; photo_center = photos.splice(n, 1)[0]; if (this.state === 0) &#123; this.separate(photos,function(photo)&#123; photo.style.left = this.range().left.x + 'px'; photo.style.top = this.range().left.y + 'px'; photo.style['transform'] = 'rotate(' + this.select(-90, 90) + 'deg) scale(1)'; &#125;,function(photo)&#123; photo.style.left = this.range().right.x + 'px'; photo.style.top = this.range().right.y + 'px'; photo.style['transform'] = 'rotate(' + this.select(-90, 90) + 'deg) scale(1)'; &#125;); &#125; else if (this.state === 1) &#123; for(var s in photos)&#123; photos[s].style['transform'] = 'rotate(' + this.select(0, 360) + 'deg) scale(1) translate(500px)'; &#125;; &#125; else &#123; var r = 460; for (var s = 0; s &lt; photos.length; s++) &#123; var deg = this.select(0, 360); var sinY = Math.sin(deg * Math.PI / 180) * r; var cosX = Math.cos(deg * Math.PI / 180) * r; photos[s].style.top = ((wrap.h / 2) + sinY) + 'px'; photos[s].style.left = ((wrap.w / 2) + cosX) + 'px'; photos[s].style.transform = 'rotate(' + (deg + 90) + 'deg)' &#125;; &#125;; var navs = this.getdom('.i'); for (var i = 0; i &lt; navs.length; i++) &#123; navs[i].className = 'i'; &#125; this.getdom("#nav_" + n).className += ' i_current';&#125; rsort()函数先把所有的样式全部重置，然后把所有的.photo放入一个数组中，根据传入的索引把当前要居中的.photo取出来给其添加居中的class，剩余的用for循环给其添加随机的样式。separate()函数的作用是把剩余.photo分成两部分，然后在回调函数里给其设置样式，range()函数的主要作用是将分成两部分的.photo给区分放置，一份放居中元素的左边，一份放居中元素的右边，写这个两个函数的原因是散列时有可能全部挤在一堆了，留下一堆空白的不好看，左右两边均分一下。1234567891011121314151617181920212223242526272829303132separate:function(photos,lfn,rfn)&#123; var photos_left = photos.splice(0, Math.ceil(photos.length / 2)); var photos_right = photos; for(s in photos_left)&#123; var photo = photos_left[s]; lfn.apply(this,[photo]); &#125; for(s in photos_right)&#123; var photo = photos_right[s]; rfn.apply(this,[photo]); &#125;&#125;range: function () &#123; var range = &#123; left: &#123; x: [], y: [] &#125;, right: &#123; x: [], y: [] &#125; &#125;; var wrap = this.getwh(this.getdom('#wrap')); var photo = this.getwh(this.getdom('.photo')[0]); range.left.x = this.select(-photo.w, (wrap.w - photo.w) / 2); range.left.y = this.select(-photo.h, wrap.h); range.right.x = this.select((wrap.w - photo.w) / 2, wrap.w); range.right.y = this.select(-photo.h, wrap.h); return range;&#125; this.state为0的样式就基本完成了，至于this.state成圆环状的样式写法原因参考我时间–时钟篇，这里面有说明。好了Surround函数基本完成了，下面我们开始调用，surround.getdom这个只是顺便用了Surround函数里面获取dom的函数：12345678910111213141516171819202122232425262728293031323334353637//轮播var surround = new Surround();surround.addPhotos(data());surround.getdom("#change").onchange = function () &#123; if (this.checked) &#123; var speed =surround.getdom('#speed').value; surround.getdom('#speed').onchange = function () &#123; speed = this.value; clearInterval(timer); timer = setInterval(function()&#123; surround.time(data()); &#125;, speed * 500); &#125;; timer = setInterval(function()&#123; surround.time(data()); &#125;, speed * 500); &#125; else &#123; clearInterval(timer); &#125;;&#125;;//切换样式btn();function btn() &#123; for (var i = 0; i &lt; surround.getdom('.btn').length; i++) &#123; (function (i) &#123; surround.getdom(".btn")[i].onclick = function () &#123; for (var j = 0; j &lt; surround.getdom('.btn').length; j++) &#123; surround.getdom(".btn")[j].className = 'btn'; &#125;; surround.getdom(".btn")[i].className = 'btn show'; surround.state = i; surround.rsort(surround.activeindex); &#125;; &#125;)(i);&#125;&#125;; 本文代码地址链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>小实例</tag>
        <tag>图片环绕</tag>
        <tag>图片轮播</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas --雪花图]]></title>
    <url>%2F2017%2F12%2F23%2Fsnow%2F</url>
    <content type="text"><![CDATA[昨天冬至，又到了白色相簿的季节了，︿(￣︶￣)︿笑，后天就是圣诞了，安安心心做个剩蛋老人吧(ノへ￣、)。好了好了，重庆还是没下雪，冷着不下雪，感觉好亏。既然不下，那就只有自己写点雪花了。canvas这个东西一直是想深入学习的，做出来的东西各种炫酷吊炸天，但是没啥时间，就只会点小东西，大家将就着看吧：首先既然是用canvas，那么结构就非常简单啦，html什么都不用写，用js创建canvas。我们把一张背景图放在body上，然后在canvas上进行雪花的绘制：1234567891011121314*&#123; margin: 0; padding: 0;&#125;html&#123; width: 100%; height: 100%; &#125;body&#123; width: 100%; height: 100%; background: url("./xh.jpg") center no-repeat; overflow: hidden; &#125; 这次就不用es6的写法了，用prototype吧：首先我们用requestAnimationFrame绘制动画的，先把兼容性搞一下，再创建函数snowFall，设置一下默认参数，maxFlake、flakeSize和fallSpeed，在进行初始化时，可以通过new snowFall()传入这三个参数改变雪花的样式。123456789101112131415//兼容写法requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;function snowFall(snow) &#123; snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 500; /* 最大片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花大小 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */ this.flakes = []; /* 雪花集合 */&#125; 然后我们在这个函数上添加一个start方法，调用此方法开始创建画布绘制雪花，出现下雪效果：123456789// 开始绘制雪花snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this);&#125; 接下来开始创建画布了,建立一个canvas放入body中：123456789101112131415// 创建画布function snowCanvas() &#123; var snowcanvas = document.createElement("canvas"); snowcanvas.id = "snowfall"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight || document.documentElement.clientHeight; document.getElementsByTagName("body")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext("2d"); /* 窗口大小改变的处理 */ window.onresize = function () &#123; snowcanvas.width = window.innerWidth; snowcanvas.height = window.innerHeight; &#125;&#125; 接着创建雪花的形状，这里循环一下要绘制的雪花，用一个雪运动对象设置每个雪花的参数，然后将雪花放入雪花集合中：123456//创建雪花对象function createFlakes() &#123; for (var i = 0; i &lt; this.maxFlake; i++) &#123; this.flakes.push(new flakeMove(this.canvas.width, this.canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125; 雪花运动对象，用于生成每个雪花的一系列参数：1234567891011121314//雪运动对象function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.canvasw = canvasWidth; this.canvash = canvasHeight; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 100; /* 步长 */&#125; 在雪的运动对象上添加一个render方法，用于生成雪的形状12345678910111213// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function (ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, "rgba(255, 255, 255, 0.9)"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, "rgba(255, 255, 255, 0.5)"); snowFlake.addColorStop(1, "rgba(255, 255, 255, 0)"); ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;; 在雪的运动对象上添加一个雪花的运动方法，根据传入的参数不同，来让雪向左向右运动，当雪花飞到了边界后，调用reset方法重置这个雪花的状态：123456789101112131415161718192021222324flakeMove.prototype.update = function (n) &#123; var x = this.x, y = this.y; if (n) &#123; this.velX += this.stepSize; &#125; else &#123; this.velX -= this.stepSize; &#125; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= this.canvasw || this.x &lt;= 0 || this.y &gt;= this.canvaswh || this.y &lt;= 0) &#123; this.reset(this.canvasw, this.canvash) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function (width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;; 雪花对象设置完毕后，我们开始画雪了，每次绘制前我们都要清空一下画布，然后根据雪花的集合进行遍历，调用函数让一部分雪花向左飘，一部分向右飘，然后用requestAnimationFrame继续调用画雪的函数，一帧一帧绘制雪花：12345678910111213141516171819/* 画雪 */function drawSnow() &#123; /* 清空雪花 */ this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); for (var e = 0; e &lt; this.maxFlake; e++) &#123; if (e % 3 == 0) &#123; this.flakes[e].update(0); this.flakes[e].render(this.ctx); &#125; else &#123; this.flakes[e].update(1); this.flakes[e].render(this.ctx); &#125;; &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function () &#123; drawSnow.apply(this); &#125;.bind(this));&#125; 最后我们 new snowFall()，最多绘制100个雪花，然后调用start方法，雪花就开始飞舞了：12345/* 调用及控制方法 */var snow = new snowFall(&#123; maxFlake: 100&#125;);snow.start(); 效果展示： 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>小实例</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间--时钟篇]]></title>
    <url>%2F2017%2F12%2F17%2Ftime1%2F</url>
    <content type="text"><![CDATA[这天是越来越冷了，人也越发的懒起来，早上起来简直要老命，下班回去也只想进被子里面，游戏都不想打了╮（﹀_﹀）╭，冷呀。。。。好了，写个时钟来激励一下懒惰的自己吧。 旋转方式做时钟首先要把样式给搞定，主要是围绕中心旋转的样式。围绕中心旋转形成等分状态其实有两种做法，假设html样式如下：1234567891011121314&lt;ul class="pox"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;12&lt;/li&gt;&lt;/ul&gt; 让li全部定位到pox中心，用css3的旋转rotate让其围绕中心旋转角度，再配合translate偏移，给它一个x轴的偏移量，就变成了围绕中心旋转的样式了： 123456789101112131415161718192021222324252627.box ul&#123; width: 200px; height: 200px; border-radius: 50%; border:1px solid red; position: relative; display: inline-block; margin: 100px;&#125;.box li&#123; width: 50px; height:50px; border:1px solid red; border-radius: 50%; line-height: 48px; text-align: center; position: absolute; top: 50%; left:50%; margin: -25px 0 0 -25px; transform-origin:50% 50%;&#125;var lists = document.querySelectorAll(".box .pox li");for(var i=0;i&lt;lists.length;i++)&#123; lists[i].style.cssText = `transform: rotate($&#123;i*30&#125;deg) translate(98px, -50%);`;&#125; 当然这种旋转非常的简单，但是也有一定的缺陷的，其缺点是文字什么的也一起旋转了，时钟的数字可不能一起旋转了，所以这刻度线什么的用这个简单方便，但是数字得用另一种方式。 好了万能的数学该来了，用sin和cos实现，我们把父元素所占的空间当成一个坐标轴，其宽的一半当成半径画个圆，如 r = 父元素.offsetHeight/2，其中心坐标点就是(r,r)，1234567891011121314151617181920212223&lt;ul class="pox2"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;12&lt;/li&gt;&lt;/ul&gt;var lists2 = document.querySelectorAll(".box .pox2 li");for(var j=0;j&lt;lists2.length;j++)&#123; var r = lists2[0].parentNode.offsetHeight/2, angle = j*30/180*Math.PI; x = r + r*Math.cos(angle); y = r + r*Math.sin(angle); lists2[j].style.cssText = `top:$&#123;y&#125;px;left:$&#123;x&#125;px;`;&#125; 其实理解起来也不难，先得到每个li的弧度值，然后根据三角函数计算出li的在坐标轴中的坐标，x轴的坐标为r+r*cosθ,y轴的坐标为r+r*sinθ，这里有点小知识，js的象限是顺时针开始的，初始0度是从时钟的三点方向开始的，和数学的是反着来的，当然你可能不理解，我的图也有点挫，应该画右下角的，你把右下角当成第一象限来理解要好一点，自己画一遍就什么都有了。好了，准备就绪，开始画时钟了，html结构如下。123456789101112 &lt;div class="clock"&gt; &lt;ul class="line-min"&gt;&lt;/ul&gt; &lt;ul class="line-hour"&gt; &lt;/ul&gt; &lt;ol class="number"&gt;&lt;/ol&gt; &lt;ul class="pointer"&gt; &lt;li class="hour"&gt;&lt;/li&gt; &lt;li class="min"&gt;&lt;/li&gt; &lt;li class="sec"&gt;&lt;/li&gt; &lt;li class="circle"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 初始表盘css：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152*&#123; margin: 0; padding: 0;&#125;ol,ul &#123; margin: 0; padding: 0; list-style: none;&#125;.clock &#123; position: relative; width: 200px; height: 200px; border-radius: 100%; background-color: #292a38; margin: 50px auto;&#125;/*指针*/.pointer li.circle &#123; position: absolute; top: 50%; left: 50%; transform-origin: left center; background: #fff; width: 10px; height: 10px; border-radius: 100%; margin-top: -5px; margin-left: -5px;&#125;.pointer li &#123; position: absolute; top: 50%; left: 50%; transform-origin: left center; background: #fff;&#125;.pointer li.hour &#123; width: 45px; height: 3px; margin-top: -1px;&#125;.pointer li.min &#123; width: 60px; height: 2px; margin-top: -1px;&#125;.pointer li.sec &#123; width: 80px; height: 1px; margin-top: -1px;&#125; .line-min是分刻度线，.line-hour是小时刻度线，.number是1-12的时间数字，.hour是时针，.min分针，.sec秒针，.circle中心圆点。这次我们用ES6的class来写吧,先定义一个Time类，后面的方法都是写在Time类里面的，Time里面的构造方法constructor调用初始化函数init，init就先空着吧。12345678var time = class Time&#123; constructor()&#123; this.init(); &#125; init()&#123; &#125;&#125; 为了写得方便点，我们先建立两个工具函数，addcss函数是向传入的dom中添加css样式，getclass是根据传入的css获取dom节点：123456addcss(obj,mycss)&#123; obj.style.cssText = mycss;&#125;getclass(cls)&#123; return document.querySelector(cls);&#125; 我们先来画时钟刻度线，用第一种旋转方式：12345678drawLines(wrap, total, translateX)&#123; //绘制刻度线 var gap = 360/total; for(var i=0;i&lt;total;i++)&#123; var li = document.createElement('li'); this.addcss(li,`transform:rotate($&#123;i*gap&#125;deg) translate($&#123;translateX&#125;px,-50%)`); wrap.append(li); &#125;&#125; 补上刻度css12345678910111213141516.line-hour li,.line-min li &#123; position: absolute; left: 50%; top: 50%; transform-origin: left center; background-color: #fff;&#125;.line-hour li &#123; width: 10px; height: 2px;&#125;.line-min li &#123; width: 5px; height: 2px;&#125; 我们用drawLines函数绘制刻度线，分别传入wrap（父节点），total（时钟的刻度个数，时针12个，分针是60个），translateX（第一种旋转方式x轴的偏移量），这个函数生成了刻度线li，并且添加css样式后放到了传入的父节点中。 然后我们再绘制时钟数字，当然数字可不能旋转，所以得用第二种旋转方式：由于初始度数是0，刚好是3点，所以3对应的弧度应该是0,6点是π/2，9点是π，12点是3π/2，通过传入的数字得到其对应的弧度如下：12345678910 时钟 角度 弧度 sin cos// 3:x:2r,y:r; 0 0 sin 0 cos 1// 6:x:r,y:2r; 90 π/2 sin 1 cos 0// 9:x:0,y:r; 180 π sin 0 cos -1// 12:x:r,y:0; 270 3π/2 sin -1 cos 0我们把弧度全部除以π得到// 3 0; = 3-3 = 0/6 (num-3)/6 * π// 6 1/2; = 6-3 = 3/6// 9 1; = 9-3 = 6/6// 12 3/2; = 12-3 = 9/6 我们可以推算出公式为(num-3)/6 * π，故弧度为 = (i-3)/6*Math.PI;1234567891011drawNumbers(wrap)&#123; //绘制数字时间 var r = wrap.offsetHeight/2; var child = ''; for(var i=1;i&lt;=12;i++)&#123; var angle = (i-3)/6*Math.PI; var myX = r + r*Math.cos(angle), // x=r+rcos(θ) myY = r + r*Math.sin(angle); // y=r+rsin(θ) child+=`&lt;li style="left:$&#123;myX&#125;px;top:$&#123;myY&#125;px;"&gt;$&#123;i&#125;&lt;/li&gt;`; &#125; wrap.innerHTML = child;&#125; 数字css123456789101112131415.number &#123; position: absolute; height: 140px; width: 140px; left: 50%; top: 50%; transform: translate(-50%, -50%); font-family: 'Microsoft Yahei'; font-size: 15px; color: #fff;&#125;.number li &#123; position: absolute; transform: translate(-50%, -50%);&#125; 这样数字函数也完成了，接下来我们在init初始化函数里面调用，new time()，让其生成出来：123456init()&#123; this.drawLines(this.getclass('.line-min'), 60, 85); this.drawLines(this.getclass('.line-hour'), 12, 80); this.drawNumbers(this.getclass('.number'));&#125;new time(); 我们就得到了时钟的大致样式了，只是时钟的针还不会走：最后我们写个move函数让时钟开始走动1234567891011121314151617move()&#123; var h = this.getclass('.hour'), m = this.getclass('.min'), s = this.getclass('.sec'); setInterval(function()&#123; var now = new Date(), hour = now.getHours(), min = now.getMinutes(), sec = now.getSeconds(); var hangle = 30*hour + 0.5*min -90, mangle = 6*min + 0.1*sec -90, sangle = 6*sec -90; this.addcss(h,`transform:rotate($&#123;hangle&#125;deg)`); this.addcss(m,`transform:rotate($&#123;mangle&#125;deg)`); this.addcss(s,`transform:rotate($&#123;sangle&#125;deg)`); &#125;.bind(this),1000);&#125; 其余的可能没啥问题，只有指针的角度计算这里可能要说一下，小时是12个小时，所以1个小时=360°/12=30°，当然还要加上分钟的偏移，一个小时60分钟，60分钟就要偏移30°，所以1分钟为0.5°，故小时=30*小时+0.5*分钟，当然也可以计算秒的，但是太小了(1/120)，这里就忽略不计了，分针和秒针同上。由于初始位置是3点那里，以3点为基准，故3点旋转角度为0°，1点为-60°，6点为90°，故所有角度应该减去90°再进行旋转。init()里面调用： 123456init()&#123; this.drawLines(this.getclass('.line-min'), 60, 85); this.drawLines(this.getclass('.line-hour'), 12, 80); this.drawNumbers(this.getclass('.number')); this.move();&#125; ok，一个简单的时钟就完成了。 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>小实例</tag>
        <tag>css3</tag>
        <tag>时间</tag>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的padding]]></title>
    <url>%2F2017%2F12%2F16%2Fpadding%2F</url>
    <content type="text"><![CDATA[标题党当上瘾了，讲完margin又来padding，继续继续。其实padding要比margin简单得多，说是不知道的padding，不如说是padding应用的一些小技巧，不要小看这些小东西，虽然有很多代替的方案，但是就用一点点css就解决了问题，何乐而不为呢，网页上的东西能用css解决的就尽量不要用js了。首先padding是没有负值的，想着负padding的同学可能要失望了，可以理解，内边距嘛，补白还能有负的？其实padding的功能很简单，就是填充。宽高不够，填充一下；背景不够，填充一下。 用Margin还是用Padding这可以算做是党争了吧(tab党和空格党表示不服)，其实什么时候用很简单，只是浏览时若你想在外侧添加空白且空白处不需要背景，用margin，否则用padding。当需要js触发事件时你想点击（或者其它操作）元素外面空白没有事件发生，用margin，需要发生事件用padding。其实区别很简单，margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。譬如margin垂直外边距合并如果用padding的话则不会出现合并问题，在视觉上与margin一样，当然前提是你不设置背景，也不需要精确的在这个元素上（准确说是盒模型的content）触发一些js事件。好了，该讲一些关于padding的应用了。 Padding背景图片自适应其实这个大多数应用于移动端，当然pc也能用，在设置背景图片或者说一张自适应的图片，为了不让其变形，一般宽度或者高度只设置其一，让其自适应显示，图片是等比缩放的，不会发生形变。我们布局时多数是设置其宽度让其自适应显示，但是这个东西有个缺点，图片加载不是瞬间完成的，尤其是网速较慢时，图片要等一段时间才会出来，而且图片可能会出现加载失败的情况，这回导致我们的布局变得混乱，原本放图片的位置会有其它元素顶上来。说到这里，肯定是用padding解决啦，当然有人可能会好奇，padding怎么解决呀。我们写padding的时候值可以是length（数字），也可以是%（百分比），重点就是这个百分比了，百分比是基于父元素的宽度的百分比的内边距。也就是说你父元素的宽度是100px；子元素的padding-top:100%;那么这个100%就是100px*100%。ok，如果知道图片的图片高度/图片宽度这个比例的话那么这个比例乘以图片宽度就能得到图片的自适应的高度了。简单来说就是知道图片的图片高度/图片宽度*图片自适应的宽度，那么自适应的高度也就出来了，所以我们可以用padding-top把这个高度提前占位。1234567891011121314151617181920.main&#123; width: 500px; margin:0 auto;&#125;.box&#123; position: relative; padding-top: 56.25%; /*图片高度/图片宽度*100%*/ overflow: hidden;&#125;.box img&#123; position: absolute; top: 0; width: 100%; height: 100%;&#125;&lt;div class="main"&gt; &lt;div class="box"&gt; &lt;img src=""/&gt; &lt;/div&gt;&lt;/div&gt; 上面的图片自适应宽为500px;我们计算出图片的高/宽比例，然后用padding-top:这个比例，实例为500px*高/宽，那么图片在500px宽下面的实际高度也就是这个数值，图片没加载出来的时候padding-top占据了这个高度，加载出来后正常显示。 当然，不只是用img可以这样显示，用背景图片也可以的：123456789101112131415.main&#123; width: 500px; margin:0 auto;&#125; .figure &#123; padding-top:56.25%; /*图片高度/图片宽度*100%*/ background: url("http://ouzdb04w7.bkt.clouddn.com/image/2017/10/27/timg3.jpg") no-repeat; background-size:cover; background-position:center; &#125;&lt;div class="main"&gt; &lt;div class="column"&gt; &lt;div class="figure" &gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 想要一行自适应的正方形，再配合text-align:justify;多列均匀布局，可以达到这样的效果:12345678910111213141516171819202122232425262728293031323334353637383940414243.mybox&#123; width: 100%; height: 300px; text-align: justify; text-justify: inter-ideograph; padding: 10%; box-sizing: border-box;&#125;.mybox:after&#123; content: ''; width: 100%; position: relative; display: inline-block;&#125;.mybox .box&#123; width: 12.5%; background: red; display: inline-block; position:relative; &#125;.box:before&#123; content: ''; padding-top: 100%; box-sizing: border-box; display: block; width: 0; &#125;.pox&#123; position:absolute; height:100%; width:100%; left: 0; top: 0; border: 1px solid red; box-sizing: border-box;&#125;&lt;div class="mybox"&gt; &lt;div class="box"&gt;&lt;div class="pox"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;div class="pox"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;div class="pox"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;div class="pox"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;div class="pox"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 在pc端改变窗口宽度试试。 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>选项卡</tag>
        <tag>margin</tag>
        <tag>padding</tag>
        <tag>移动端图片自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的margin]]></title>
    <url>%2F2017%2F12%2F15%2Fmargin%2F</url>
    <content type="text"><![CDATA[当了一回标题党了(震惊！99%的人都不知道XXXX &lt;(￣︶￣)&gt;)，本文是对我所了解的margin的一些说明，希望能给大家带来些许有意思的知识。margin和padding是css中应用最多的了吧，没有之一，这两兄弟帮我们解决了一个又一个的布局问题。好了，来看看margin的一些应用吧。 何为margin来看看官方的说明: 边界，元素周围生成额外的空白区。“空白区”通常是指其他元素不能出现且父元素背景可见的区域。——CSS权威指南 CSS 边距属性定义元素周围的空间。通过使用单独的属性，可以对上、右、下、左的外边距进行设置。也可以使用简写的外边距属性同时改变所有的外边距。——W3School margin就是盒模型的外边距，它最基本用途就是控制元素周围空间的间隔，把一个个元素分隔开来。margin始终是透明的。 垂直外边距合并问题外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 其实这个问题一般常见于父元素和子元素，第一个子元素的margin-top会顶开父元素与父元素相邻元素的间距，其原因是第一个子元素的margin-top和父元素的margin-top没有东西与其分隔开来，导致了两者的margin-top重合了。简单点说就是：父元素的第一个子元素的上边距margin-top如果碰不到有效的东西如border或者padding将两者的margin-top阻隔，就会不断一层一层的找自己祖先元素的麻烦，直到有隔断的东西，或者找到了最终的父元素。当然解决办法太多了： 其子元素浮动、inline-block、绝对定位; 父元素建立BFC（float（除了none）、overflow（除了visible）、display（table-cell/table-caption/inline-block）、position（除了static/relative）），大家常用的overflow: hidden;来解决就是这个做法。 父元素和子元素隔断两者的margin-top，也就是父元素添加:after，padding-top，border-top，总之能隔断就行 负margin首先盒模型的大小等于盒子的border+padding+正margin，负margin是不会影响其大小的。那么负margin有啥用呢？负margin主要是让元素脱离自身的位置发生移动，当元素margin的top和left是负值时会引起元素的向上或向左位置移动（当然元素移动了，会导致后面的元素一起动）。而当元素margin的bottom和right是负值时会影响右边和下边相邻元素的参考线（比如margin-bottom: -100px;会让它下面挨着的元素上移100px）。 负margin的应用： 悬停图片放大其实这个东西有很多人是用transform: scale()来做的，让图片放大，但是这个其实也可以用负margin来做，让img宽高变大然后通过负margin让其中心位置不变，当然这个兼容性特好，不追求动画效果的话ie7都没啥问题的。.box{margin: 50px;width: 200px;height: 200px;border: 1px solid #000;overflow: hidden;}.article-entry img.pox{max-width:inherit;width: 200px;height: 200px;margin:0;background-color: red;transition: all 0.4s ease; vertical-align: top;}.box:hover .pox{margin: -25px 0 0 -25px!important;width: 250px!important;height: 250px!important;}.box a{display: block;height: 100%;width: 100%;} 1234567891011121314151617181920212223&lt;div class="box"&gt; &lt;img src="http://ouzdb04w7.bkt.clouddn.com/image/2017/10/27/timg1.jpg" alt="" class="pox"/&gt;&lt;/div&gt;.box&#123; margin: 50px; width: 200px; height: 200px; border: 1px solid #000; overflow: hidden;&#125;.pox&#123; width: 200px; height: 200px; background-color: red; transition: all 0.4s ease; vertical-align: top;&#125;.box:hover .pox&#123; margin: -25px 0 0 -25px; width: 250px; height: 250px;&#125; 选项卡负margin是可以用作于特殊样式的选项卡的，而且负margin可以实现border重叠，也就是两个紧挨着的1px border可以用margin-left:-1px让其重叠，变成1px的border，下面的选项卡就只是使用负margin达到了效果，当然还有很多种方式可以实现，但是这种方式简单快捷，ie7什么的不在话下。 123456789101112131415161718192021ul.list&#123; height:38px; line-height: 38px; overflow: hidden; list-style: none; background: #f8f8f8; margin-bottom: -1px; &#125;#list li&#123; float: left; width: 99px; text-align: center; border-left: 1px #e5e5e5 solid; border-right: 1px #e5e5e5 solid; margin-left: -1px; cursor: pointer;&#125;#list .active&#123; position: relative; background-color: #FFf; &#125; 绝对定位效果负margin是可以达到绝对定位的视觉效果的，但是有要注意：负margin的重叠的话背景会被正常元素覆盖，ie7则相反。.mybox{width:200px;height:112px}.mybox img{width:100%;height:100%}.mybox span{margin-top:-100px;display:block;color:#FFF;text-align:right;margin-right:10px}特大喜讯 12345678910111213141516.mybox&#123; width: 200px; height: 112px;&#125;.mybox img&#123; width: 100%; height: 100%;&#125;.mybox span&#123; top: -100px; display:block; color: #FFF; text-align:right; margin-right: 10px; background-color: red;&#125; 自适应布局当然，负margin最出名的应用还是自适应上的。双飞翼布局：.wrapper{color:#fff}.col{float:left}.myheader{height:50px;background-color:#666;color:#fff;line-height:50px;text-align:center}.main{width:100%;background-color:#555}.main-wrap{margin:0 100px 0 100px;height:200px}.left{width:100px;height:200px;margin-left:-100%;background-color:#999}.right{width:100px;height:200px;margin-left:-100px;background-color:#999}.footer{height:50px;background-color:#666;color:#fff}.clearfix{overflow:hidden}header main left right footer 123456789101112131415161718192021222324252627.wrapper &#123;color:#fff;&#125;.col &#123;float: left;&#125;.header &#123;height: 50px;background-color: #666;color:#fff;line-height: 50px;text-align: center;&#125;.main &#123;width: 100%;background-color: #555;&#125;.main-wrap &#123;margin: 0 100px 0 100px;height: 200px;&#125;.left &#123;width: 100px;height: 200px;margin-left: -100%;background-color: #999;&#125;.right &#123;width: 100px;height: 200px;margin-left: -100px;background-color: #999;&#125;.footer &#123;height: 50px;background-color: #666;color:#fff;&#125;.clearfix::after&#123;content: "";display:block;clear:both;visibility:hidden;height:0;overflow:hidden;&#125;&lt;div class="myheader clearfix"&gt; header&lt;/div&gt;&lt;div class="wrapper clearfix"&gt; &lt;div class="main col"&gt; &lt;div class="main-wrap"&gt; main &lt;/div&gt; &lt;/div&gt; &lt;div class="left col"&gt; left &lt;/div&gt; &lt;div class="right col"&gt; right &lt;/div&gt;&lt;/div&gt;&lt;div class="footer"&gt;footer&lt;/div&gt; 圣杯布局： .wrapper2{padding:0 100px 0 100px;color:#fff}.col2{position:relative;float:left}.header2{height:50px;background-color:#666;color:#fff;text-align:center;line-height:50px}.main2{width:100%;height:200px;background-color:#555}.left2{width:100px;height:200px;margin-left:-100%;left:-100px;background-color:#999}.right2{width:100px;height:200px;margin-left:-100px;right:-100px;background-color:#999} header main left right footer123456789101112131415161718192021222324.wrapper2 &#123;padding: 0 100px 0 100px; color:#fff;&#125;.col2&#123;position: relative;float: left;&#125;.myheader &#123;height: 50px;background-color: #666;color:#fff;text-align: center;line-height: 50px;&#125;.main2 &#123;width: 100%;height: 200px;background-color: #555;&#125;.left2 &#123;width: 100px;height: 200px;margin-left: -100%;left: -100px;background-color: #999;&#125;.right2 &#123;width: 100px;height: 200px;margin-left: -100px;right: -100px;background-color: #999;&#125;.footer &#123;height: 50px;background-color: #666; color:#fff;&#125;.clearfix::after&#123;content: "";display:block;clear:both;visibility:hidden;height:0;overflow:hidden;&#125; &lt;div class="myheader clearfix"&gt; header &lt;/div&gt; &lt;div class="wrapper2 clearfix"&gt; &lt;div class="main2 col2"&gt; main &lt;/div&gt; &lt;div class="left2 col2"&gt; left &lt;/div&gt; &lt;div class="right2 col2"&gt; right &lt;/div&gt; &lt;/div&gt; &lt;div class="footer"&gt;footer&lt;/div&gt; margin配合定位绝对居中margin还可以配合绝对定位实现绝对居中的功能 .box3{width:400px;height:400px;background-color:#e5e5e5;position:relative}.pox3{width:100px;height:100px;background-color:#000;margin:auto;position:absolute;top:0;left:0;bottom:0;right:0} 1234567891011121314151617 .box&#123; width: 400px; height: 400px; background-color: #e5e5e5; position: relative;&#125;.pox&#123; width: 100px; height: 100px; background-color: #000; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125;&lt;div class="box"&gt; &lt;div class="pox"&gt;&lt;/div&gt;&lt;/div&gt; ok，这就是我所认识的margin，可能有所遗漏，不过暂时也记不得了，后面再补充，下一篇准备padding吧。本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>负margin</tag>
        <tag>自适应左右布局</tag>
        <tag>选项卡</tag>
        <tag>margin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-align:justify;]]></title>
    <url>%2F2017%2F12%2F13%2Fjustify%2F</url>
    <content type="text"><![CDATA[text-align，这东西主要应用于实现两端对齐文本效果，当我们有大篇幅的文本内容时，文字换行会出现文本两端不居中的情况。如图： 我们想让其美观一点，在其文本标签加上text-align:justify文字就实现了两端对其了，当然，这个兼容性还是挺不错的，ie的话再加上text-justify: inter-ideograph基本上都能实现对其，但是也有一些怪异的情况，比如在手机上一些手机自带的浏览器，还有uc浏览器(手机浏览器中的ie)是不生效的，我还得再加上word-break: break-all告诉浏览器我们要进行断句了，让其允许在单词内换行，这样也就实现了对齐了。 12345p&#123; text-align: justify; text-justify: inter-ideograph; word-break: break-all; &#125; 当然，text-align:justify如果就这点东西，我也不会专门拿来写这篇博客(能凑凑数还是可以的)，目前很多人在写多列均匀布局都是使用的flex和它的兄弟-webkit-box，用肯定是非常好用，但是最蛋疼的问题是兼容性不是那么的好，移动端加了-webkit-前缀基本上没啥问题，但是ie这个东西是你要做兼容的话是绕不开的，只得放弃好用的了，当然你也可以用table布局，用js计算什么的，当时感觉为了一个均匀布局太不划算了。这时需要我们的主角text-align:justify来当救世主了，巧妙的使用text-align:justify可以实现多列均匀布局，并且兼容性强大，ie6什么的不在话下。许多人直接用text-align:justify时发现并不能实现两端对其，而且有时用jq添加节点时也对其不了，其实要让text-align:justify生效你得满足几个条件才行：首先text-align:justify，顾名思义，其子标签必须是inline-block或者inline，并且它不会处理被打断的行和最后一行。也就是说当你的行数只有一行时，text-align不会生效的，所以我们要处理一下，伪造一个最后一行，让你的行数不是处于最后。可以用父标签的:after进行伪造。1234567891011121314&lt;div class="justify"&gt; &lt;div class="item"&gt; &lt;span&gt;1&lt;/span&gt; &lt;p&gt;第一，绝对不意气用事&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;span&gt;2&lt;/span&gt; &lt;p&gt;第二，绝对不漏判任何一件坏事&lt;/p&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;span&gt;3&lt;/span&gt; &lt;p&gt;第三，绝对裁判的公正漂亮&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516.justify&#123; text-align: justify; text-justify: inter-ideograph; &#125;.justify .item&#123; display:inline-block; *zoom:1; *display: inline; text-align: center;&#125; .justify:after&#123; content: ''; width: 100%; position: relative; display: inline-block; &#125; 但是ie8以下可不认这个东西，要兼容ie的话我们可以在父标签html的最后加个ie版本判断的html语句（inline-block也要注意兼容），当时ie8以下时我们显示一个空的文本标签。两者同时运用没啥冲突，基本上完美兼容了。12345678910111213.justify b&#123; display: inline-block; position:relative; height:0px; width:100%; &#125; &lt;div class="justify"&gt; ...... &lt;!--[if lte IE 7]&gt; &lt;b&gt;&lt;/b&gt; &lt;![endif]--&gt; &lt;/div&gt; 有时候我们用jq进行动态添加时发现css也用了，怎么还是不能对其，那是因为对其还要有个条件，就是子元素必须要有间隙，不能紧挨着。比如：123456&lt;div class="justify"&gt; &lt;i&gt;1&lt;/i&gt;&lt;i&gt;2&lt;/i&gt;&lt;i&gt;3&lt;/i&gt;&lt;i&gt;4&lt;/i&gt; &lt;!--[if lte IE 7]&gt; &lt;b&gt;&lt;/b&gt; &lt;![endif]--&gt; &lt;/div&gt; 这种事不能对齐的，所以在压缩html的时候要注意一下，当然jq动态添加你要留个空格什么的，不然也不能对齐。比如1$(".justify").append("&lt;i&gt;1&lt;/i&gt; ") //注意括号里面要留空格 好了，看个示列吧，ie6没试过，不过两端对齐应该没啥显示问题，js效果的话要ie8哦： 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>多列均匀布局</tag>
        <tag>文字两端对齐</tag>
        <tag>text-align:justify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3复选框美化及css3页面滚动]]></title>
    <url>%2F2017%2F12%2F05%2Fcss3check%2F</url>
    <content type="text"><![CDATA[css的东西还是更新得快呀。(主要是js比较菜)，这里主要是把checkbox美化一下，radio什么的参考checkbox一样的道理，css能做的东西还是挺多的，虽然不是那么实用，但是选项卡，页面滚动，图片轮播什么的，都可以做，今天的主角就是css3的:checked外加上css3的~和+选择:checked是被选中的 input 元素，当这东西后面跟上~和+后，你就可以让选中的input对应的标签做点事情了。~ 兄弟选择符，是指选择元素后面的所有兄弟元素，比如a~p就是指a标签后面所有的p标签。+ 相邻选择符，是指选择元素后面相邻的兄弟元素，这个只选择一个。 浏览器自带的复选框和单选框的样式简直对不起这网络信息的发展：复选框：&nbsp;&nbsp;单选框&nbsp;&nbsp;1&nbsp;2&nbsp;3 是不是丑出天际了，我们的工作就是把丑的东西改装成美的东西给用户看的，自然少不了各种美化了，先来个checkbox的切换吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;label class="switch"&gt; &lt;input type="checkbox"&gt; &lt;div class="switchbox"&gt;&lt;/div&gt;&lt;/label&gt; input[type="checkbox"]&#123; display: none; &#125; label.switch&#123; display: inline-block; width: 60px; height: 30px; cursor: pointer;&#125;label.switch .switchbox&#123; height: 100%; box-sizing: border-box; position: relative; border-radius: 34px; background-color: #e5e5e5; transition: all 0.3s;&#125;label.switch input[type="checkbox"]+.switchbox:after&#123; height: 30px; width: 30px; border-radius: 50%; box-sizing: border-box; border: 1px solid #dddddd; position: absolute; left: 0; top: 0; content: ''; transition: all 0.3s; background-color: #ffffff; transform: translateX(0); box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); z-index: 2;&#125; label.switch input[type="checkbox"]+.switchbox:before&#123; content: ' '; position: absolute; left: 2px; top: 2px; width: 56px; border-radius: 26px; box-sizing: border-box; height: 26px; background: #fff; z-index: 1; transition: all 0.3s; transform: scale(1);&#125;label.switch input[type="checkbox"]:checked+.switchbox&#123; background-color: #4cd964;&#125;label.switch input[type="checkbox"]:checked+.switchbox:after&#123; transform: translateX(30px);&#125;label.switch input[type="checkbox"]:checked+.switchbox:before&#123; transform: scale(0);&#125; 首先我们要把丑陋的checkbox给隐藏掉，用label把checkbox包裹住，这样点击label会触发checkbox的选择，然后主要是用:checked+，当checkbox选中后选择switchbox和switchbox的伪元素进行变化，加上一个过渡动画什么的就改装好了，当然其他什么的也是这个原理，css代码太多了，就不一一贴出来了，有兴趣的去看代码链接吧。来看看所有改装的样式：至于css滚动则是用几个radio，将其opacity设为0;让其透明，然后覆盖在文字上，你点击文字就选中了radio，body只显示当前窗口，超出隐藏，然后通过:checked ~让.main的transform: translateY变化，就达到了滚动的效果;123456789101112131415161718192021222324252627282930&lt;input type="radio" name="nav" class="nav-1" checked="checked"/&gt; &lt;a class="nav"&gt;首页&lt;/a&gt; &lt;input type="radio" name="nav" class="nav-2"/&gt; &lt;a class="nav"&gt;新闻&lt;/a&gt; &lt;input type="radio" name="nav" class="nav-3"/&gt; &lt;a class="nav"&gt;娱乐&lt;/a&gt; &lt;input type="radio" name="nav" class="nav-4"/&gt; &lt;a class="nav"&gt;音乐&lt;/a&gt; &lt;input type="radio" name="nav" class="nav-5"/&gt; &lt;a class="nav"&gt;其他&lt;/a&gt;&lt;section class="main"&gt;&lt;/section&gt; .nav-1:checked ~ .main&#123; transform: translateY(0%); &#125; .nav-2:checked ~ .main&#123; transform: translateY(-100%); &#125; .nav-3:checked ~ .main&#123; transform: translateY(-200%); &#125; .nav-4:checked ~ .main&#123; transform: translateY(-300%); &#125; .nav-5:checked ~ .main&#123; transform: translateY(-400%); &#125; 本文代码地址链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>css</tag>
        <tag>css特效</tag>
        <tag>checkbox</tag>
        <tag>radio</tag>
        <tag>伪元素</tag>
        <tag>复选框美化</tag>
        <tag>css3页面滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探Promise]]></title>
    <url>%2F2017%2F12%2F02%2Fpromise%2F</url>
    <content type="text"><![CDATA[一个星期没更新了，先来个小游戏来放松放松，勇者大战魔王： 考验人品的时候到了，反复进攻，看你能几次进攻打败魔王。 上面只是个小例子，如何实现上面的效果呢，这就要说到我们今天的正主了–Promise，Promise译为承诺。在ES6发布时Promise被ES6列为正式规范，成为最重要的特性之一，Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。简单来说就是把一个函数放进去，符合你定的规范，就返回成功回调函数，否则返回失败回调函数。与其说是承诺，这里我更倾向它是先知，它可以预先将未来发生的事，你无需等待最终结果出来，可以继续规划你代码的走向，比如说我们要败魔王，就要先干掉魔王身边的小弟，而你只需要规划好先打小弟，在打魔王就行了。 Promise首先我们来看看这个东西到底怎么用1new Promise( function(resolve, reject) &#123;...&#125; 先看它的语法，它是由new Promise()传入一个带有 resolve 和 reject 两个参数的函数 。我们调用试一试123new Promise(function(resolve, reject)&#123; console.log(1);&#125;); emmmmmm……，直接就console了，感觉没啥用，但是我们知道了在Promise的构造函数执行时，传入那个函数会同步执行。在看看文档，哦，Promise相当于一个承诺，当发出承诺时只是一个中立的状态，承诺是有失败和成功的，resolve代表成功，调用resolve时就代表这个承诺成功了，调用reject时就代表这个承诺失败了。原来如此，是要调用resolve和reject来触发状态呀，然后通过这个状态的改变来执行Promise实例上的then、catch方法，new Promise().then(成功调用,失败调用)，new Promise().then(成功调用).catch(失败捕获)，好了继续。 then和catch123456new Promise(function(resolve, reject)&#123; console.log(1); resolve('aaa'); &#125;).then(function(val)&#123; console.log(val); &#125;); 嗯，成功的承诺触发了成功的函数了，看看失败的，当然失败的也可以用then的第二个函数调用。12345678new Promise(function(resolve, reject)&#123; console.log(1); reject('aaa'); &#125;).then(function(val)&#123; console.log(val); &#125;).catch(function(val)&#123; console.log(val+'error'); &#125;); 嗯，失败也触发了。这下直观多了，其实上面的catch等同于下面的写法。12345678new Promise(function(resolve, reject)&#123; console.log(1); reject('aaa'); &#125;).then(function(val)&#123; console.log(val); &#125;).then(undefined, function(val)&#123; console.log(val+'error'); &#125;);; then方法可以返回一个新的Promise实例，因此可以采用链式写法，即then方法后面再调用另一个then方法。123456789101112131415var aaa = function(num)&#123; return new Promise(function(resolve,reject)&#123; if(num&gt;10)&#123; resolve(num); &#125;else&#123; reject('这个小于10'+num) &#125; &#125;)&#125;aaa(11).then(function(data1) &#123; return aaa(9)&#125;).catch(function(err)&#123; console.log(err);&#125;); promise对象的错误会一直向下抛出，直到被catch所捕获，看下面，也就是说catch先找第一个aaa(9)看看这个是不是失败的承诺，是就打印错误，不是就找第二个aaa(8)，后面同理，也就是catch可以捕获它前面的所有Promise实例的错误，都会找到最先出错的那个，然后捕获。12345aaa(9).then(function(data1) &#123; return aaa(8)&#125;).catch(function(err)&#123; console.log(err); &#125;); 其实总的来说Promise层层回调给简化了，用一个承诺的状态来使需要的回调函数调用，可以采用链式写法，避免了回调函数的层层嵌套。比如我们想写三个异步执行的事件，a是2秒后执行，b是1秒，c是3秒，同时跑的话完成顺序肯定是b-&gt;a-&gt;c，但是我想按照a-&gt;b-&gt;c，按顺序执行，那么肯定是a完成后调用b，b完成后再调用c，三个事件嵌套，用Promise我们可以这样做，是不是更直观。123456789101112131415161718192021222324252627282930var a = function()&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('a'); &#125;,2000); &#125;)&#125;var b = function()&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('b'); &#125;,1000); &#125;)&#125;var c = function()&#123; return new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('c'); &#125;,3000); &#125;)&#125;a().then(function(val)&#123; console.log(val+'执行'); return b();&#125;).then(function(val)&#123; console.log(val+'执行'); return c();&#125;).then(function(val)&#123; console.log(val+'执行');&#125;); Promise并行有时我们想几个异步事件一起执行，但是想一起拿到结果，那么这个结果应该是在最后执行那个事件上完成后获得，但是有些时候我们往往不知道这几个异步事件谁最后完成。Promise.all可以实现这样的功能，说通俗点，就是一群人跑步，当最后一个人跑完了，比赛结束，把每个人跑的结果装在数组里返回。123Promise.all([a(),b(),c()]).then(function(val)&#123; console.log(val);&#125;) Promise竞速几个异步事件一起执行，我们想有个执行完了就返回，还是一群人跑步，当第一个人跑完了，比赛结束，返回第一个人跑的结果，这就叫竞速，可以用这个写超时。123Promise.race([a(),b(),c()]).then(function(val)&#123; console.log(val);&#125;) resolve()和reject()Promise自身也有resolve()和reject()方法，其做用是给定Promise对象一个确切的状态，也就是Promise.resolve()这是一个成功的承诺，只会调用成功的方法，reject()同理，当然这二者是不能共存的，两个都存在的情况下，后面的会把前面的覆盖。1234567var d = Promise.resolve("succ");//var d = Promise.reject("err");d.then(function(val) &#123; console.log(val); //succ&#125;,function(err)&#123; console.log(err); //err&#125;); ok，接下来我们该实践一下了，就拿开头的勇者大战魔王吧： 勇者大战魔王首先我们定义三个关卡，关卡里面有骷髅，守卫，魔王12345var ul = document.querySelector('ul'); //装提示文字var monster = [];var skeleton = []; //骷髅堆，能力随机生成var elite = []; //守卫堆，能力随机生成var devil = [&#123;attack:200,defense:200,life:300&#125;]; //魔王，都是魔王了，能力肯定不是像杂兵一样随机了，攻击200，防守200，生命300 然后我们写一个批量生成杂兵的函数和一个随机函数12345678910111213141516171819//批量生成杂兵function generate(arr,num,min,max,life,experience)&#123; //装杂兵的数组，杂兵个数，随机最小值，随机最大值，生命值，经验 for(var i=0;i&lt;num;i++)&#123; var random = Rand(min,max); arr.push(&#123; attack:random, defense:random, life:life, experience:experience &#125;) &#125; return arr;&#125;//随机函数，根据传入的最大和最小值生成二者之间的随机值。 function Rand(Min,Max)&#123; var Range = Max - Min; var Rand = Math.random(); return(Min + Math.round(Rand * Range)); &#125; 传入参数生成骷髅和守卫，把这三个关卡装入monster中123skeleton = generate(skeleton,10,2,6,50,10);elite = generate(elite,3,10,30,100,50);monster.push(skeleton,elite,devil); 我们创建一个勇者，勇者有他的面板attribute和他的状态state以及他的一系列的经历函数request123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var brave = &#123; attribute:&#123; attack:10, defense:4, life:200, experience:0, Grade:0, &#125;, state:function(state)&#123; var text = `勇者$&#123;state&#125;，攻击$&#123;this.attribute.attack&#125;,防御$&#123;this.attribute.defense&#125;，生命$&#123;this.attribute.life&#125;，等级$&#123;this.attribute.Grade&#125;`; addli(text); //页面提示文字生成 &#125;, request:function(obj)&#123; var monster = obj.monster; for(var i in monster)&#123; var kill; //需要攻击怪物次数 if(Math.random()&gt;0.4)&#123; //40%概率致命一击 var sh = this.attribute.attack-monster[i].defense; if(sh&gt;0)&#123; //打怪时是否破防 kill = Math.ceil(monster[i].life/sh); &#125;else&#123; kill = 10000; &#125; &#125;else&#123; var sh = this.attribute.attack*2-monster[i].defense; if(sh&gt;0)&#123; kill = Math.ceil(monster[i].life/sh); &#125;else&#123; kill = 10000; &#125; &#125; var Injured = monster[i].attack-this.attribute.defense; //受到怪物伤害 if(kill===10000)&#123; this.attribute.life = 0; //打怪不破防生命直接清0 &#125;else&#123; this.attribute.life = Injured&gt;0?this.attribute.life-(kill*Injured):this.attribute.life; //打怪后剩余生命 &#125; if(this.attribute.life&gt;0)&#123; //存活 this.attribute.experience+=monster[i].experience; //经验++ if(this.attribute.experience==50)&#123; //经验50升级，升级后属性提升，有概率大幅度提升 Math.random()&gt;0.4?this.attribute.attack = this.attribute.attack*2:this.attribute.attack = this.attribute.attack*3; Math.random()&gt;0.4?this.attribute.defense = this.attribute.defense*2:this.attribute.defense = this.attribute.defense*3; this.attribute.life = this.attribute.life+50; this.attribute.Grade = this.attribute.Grade+1; this.state('升级'); &#125; if(this.attribute.experience==150)&#123; //经验150升级 Math.random()&gt;0.3?this.attribute.attack = this.attribute.attack*2:this.attribute.attack = this.attribute.attack*4; Math.random()&gt;0.3?this.attribute.defense = this.attribute.defense*2:this.attribute.defense = this.attribute.defense*4; this.attribute.life = this.attribute.life+100; this.attribute.Grade = this.attribute.Grade+1; this.state('升级'); &#125; if(this.attribute.experience==250)&#123; //经验250升级 Math.random()&gt;0.2?this.attribute.attack = this.attribute.attack*2:this.attribute.attack = this.attribute.attack*5; Math.random()&gt;0.2?this.attribute.defense = this.attribute.defense*2:this.attribute.defense = this.attribute.defense*5; this.attribute.life = this.attribute.life+150; this.attribute.Grade = this.attribute.Grade+1; this.state('升级'); &#125; obj.success(this.state.bind(this)); //击杀成功后显示勇者状态 &#125;else&#123; obj.error(this.state.bind(this)); //生命归0后显示勇者状态 return; &#125; &#125; &#125;&#125; 我们用Promise传入怪物名称，怪物属性，打赢后的回调函数，失败后的回调函数。12345678910111213141516171819202122232425var Raiders = function(arr,name)&#123; return new Promise(function(resolve,reject)&#123; brave.request(&#123; name:name, monster:arr, success:function(fn)&#123; var text = `攻略$&#123;this.name&#125;成功`; addli(text); fn('状态'); resolve(); &#125;, error:function(fn)&#123; fn('状态'); reject(this.name); &#125; &#125;) &#125;)&#125;//生成提示文字function addli(text)&#123; var li = document.createElement('li'); li.innerText = text; ul.appendChild(li); console.log(text);&#125; ok，万事具备了，勇者开始进攻：1234567891011121314151617181920212223 &lt;button onclick="aaa()"&gt;进攻&lt;/button&gt;function aaa()&#123; ul.innerHTML = ''; brave.attribute = &#123; attack:10, defense:4, life:200, experience:0, Grade:0, &#125;; Raiders(monster[0],'骷髅').then(function()&#123; return Raiders(monster[1],'守卫');&#125;).then(function()&#123; return Raiders(monster[2],'魔王');&#125;).then(function()&#123; var text = `成功击败魔王`; addli(text);&#125;).catch(function(name)&#123; var text = `攻略$&#123;name&#125;失败，请从新来过` addli(text);&#125;)&#125; 好了，是不是挺有意思的，用了Promise感觉所有的事情都清晰化了，没有那么多复杂的函数嵌套了。本文代码地址：链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>小实例</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3导航]]></title>
    <url>%2F2017%2F11%2F26%2Fcss3nav%2F</url>
    <content type="text"><![CDATA[勤奋（懒惰）的我又更新了，又是css（js比较难写，css随便糊弄过去就行了），周日过得好快，感觉一觉就睡过去了，天冷得不想起床(‾▽‾)”。 css3导航其实css3的特效导航有很多很多种，我只是列了一些给大家参考参考，在曲面阴影里面我就说过:after和:before，其实大多说导航的特效都是依赖于这两兄弟完成的（其他标签也行，不过结构就太复杂了，不推荐），这两兄弟写好样式，然后通过css3的transform来做旋转，放大，缩小，增减，倾斜等等，然后通过鼠标移入:hover或者用js的mouse事件把它的transform设置为初始样式，它就可以通过css3的过渡transition从旋转，放大，缩小，增减，倾斜等状态变成正常状态，即生成了一个过渡动画。:after和:before的content可以用来插入内容，比如12345&lt;span data-hover="home"&gt;首页&lt;/span&gt;span::before &#123; content: attr(data-hover);&#125; 那么:before中的类容就是home，当然data-hover不是必须叫这个，这只是一个自定义命名而已，你可以改成其他的，不过准守html5规范，命名还是在前面尽量要有data-。其实这玩意儿也没啥技术难度，多写写很简单的，就不多说什么了，给大家几个参考参考:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990.nav1 a span &#123; background: #587285; box-shadow: inset 0 3px #2f4351; transition: background 0.6s; transform-style: preserve-3d; transform-origin: 0% 50%;&#125;.nav1 a span::before &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #fff; color: #2f4351; content: attr(data-hover); transform: rotateX(270deg); transition: transform 0.6s; transform-origin: 0 0;&#125;.nav1 a span:hover&#123; background: #2f4351;&#125;.nav1 a span:hover::before&#123; transform: rotateX(0deg);&#125;.nav2 a &#123; color: #237546; text-shadow: none; transition: color 0.3s; &#125;.nav2 a::before &#123; top: 0; transform: translateY(-10px);&#125;.nav2 a::after&#123; bottom: 0; transform: translateY(10px);&#125;.nav2 a::before, .nav2 a::after &#123; position: absolute; width: 100%; height: 2px; background: #fff; content: ''; opacity: 0; transition: opacity 0.3s, transform 0.3s; left: 0;&#125;.nav2 a:hover&#123; color: #FFFFFF;&#125;.nav2 a:hover::before,.nav2 a:hover::after&#123; transform: translateY(0px); opacity: 1;&#125;.nav3 a span&#123; position: relative; display: inline-block; width: 100%; background: #e35041; transition: transform 0.4s, background 0.4s; transform-style: preserve-3d; transform-origin: 50% 50% -100px; &#125;.nav3 a:hover span&#123; transform:rotateY(-90deg); background:#b53a2d;&#125;.nav3 a span::before &#123; position: absolute; top: 0; left: 100%; width: 100%; height: 100%; background: #b53a2d; content: attr(data-hover); transition: background 0.4s; transform: rotateY(90deg); transform-origin: 0 50%; pointer-events: none;&#125;.nav3 a:hover span::before&#123; background:#E35041;&#125; 效果展示： 感兴趣的话可以去看代码链接参考参考本文代码地址链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>css</tag>
        <tag>css特效</tag>
        <tag>伪元素</tag>
        <tag>css3导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲面阴影]]></title>
    <url>%2F2017%2F11%2F25%2Fcurveimg%2F</url>
    <content type="text"><![CDATA[讲了几次js的东西，换换口味了，讲讲css的东西吧，其实css写好了是非常有意思的，一些css的特效看起来非常炫酷，且流畅度要比js好得多。一件好的作品，不仅要好用，还要带给用户视觉上以美的享受，许多东西把细微的东西做得好一些，能有非常棒的体验。说是曲面阴影，其实应该还要加上翘边阴影的，这两个实现方法其实都差不多，都是用css的伪元素来实现的，说到:after和:before，其实css3中许多东西的动画都用到了这两兄弟，应用挺广泛的。 曲面阴影曲面阴影的原理是将:after和:before定位到主体的一侧，且其z-index为负数，也就是在主体的下方，让后给其添加box-shadow属性即可，不过注意的是:after和:before的宽度一定要小于主体，主要是其两侧的box-shadow不要显示出来就行了，这样主体就只有一侧有阴影显示出来，造成了这一边是曲面的视觉差，看起来颇有立体感。12345678910111213.box:after,.box:before&#123; content: ''; position: absolute; bottom: 0px; top: 50%; left: 20px; right: 20px; background: red; border-radius: 100px/10px; box-shadow: 0 0px 30px rgba(0,0,0,0.8); z-index: -10; transition: all 1s; &#125; 翘边阴影翘边阴影主要是将主体的四个边加上阴影，让主体看起来四边都是翘起来的一样，我们先将:after和:before的高度和宽度设置为主体的90%左右（根据具体情况细微调整），然后将其用css3的transform: skew 将其倾斜，rotate将其选择，其实就是把它变成平行四边形然后旋转角度，让主体完全覆盖住这个四边形就行了。12345678910111213141516171819.imgbox:after,.imgbox:before&#123; content:''; position:absolute; z-index:-1; background:transparent; width:88%; height:90%; right:20px; bottom:15px; transition: all 1s;&#125;.imgbox:after&#123; transform:skew(-12deg) rotate(-5deg); box-shadow:20px 20px 20px rgba(0,0,0,0.8);&#125;.imgbox:before&#123; transform:skew(12deg) rotate(5deg); box-shadow:-20px 20px 20px rgba(0,0,0,0.8);&#125; 还是上图吧：图是不是很挫，～(￣▽￣～)(～￣▽￣)～手残党，不要在意这些细节。 效果展示： 本文代码地址链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>css</tag>
        <tag>伪元素</tag>
        <tag>box-shadow</tag>
        <tag>曲面阴影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瀑布流小实例]]></title>
    <url>%2F2017%2F11%2F22%2Fwaterfall%2F</url>
    <content type="text"><![CDATA[网站备案终于下来了，等了十几天，不容易呀，顺便搞了个免费的https证书，把评论也换成畅言的了，来必力太挫了，ui看见想打人系列。瀑布流，又称瀑布流式布局。其特点是随着页面滚动条向下滚动，不断加载数据块并附加至当前尾部。从Pinterest开始兴起，国内也有许多网站采用这种样式，不过大多数为了节约代码采用的是等宽等高的样式。今天我要演示的是等宽不等高如何进行瀑布流加载。 html结构由于我们这里瀑布流的布局是采用绝对定位的，所以html结构非常简单，加载的html都是通过js操控的。123456789&lt;main&gt; &lt;div id="main"&gt; &lt;div class="pin"&gt; //js生成的 &lt;div class="box"&gt; &lt;img src="./images/0.jpg"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/main&gt; csscss没什么好说的，也是非常简单，由于其等宽不等高的性质，我们把.box的宽度都定死,这里由于要整体居中，由于.pin有padding-left:14px;，故而而把#main设置了left: -7px;让其整体居中一下。123456789101112131415161718192021*&#123;padding: 0;margin:0;&#125;#main&#123; position: relative; left: -7px;&#125;.pin&#123; padding: 14px 0 0 14px; float:left;&#125;.box&#123; padding: 10px; border:1px solid #ccc; box-shadow: 0 0 6px #ccc; border-radius: 5px; width: 182px; box-sizing: border-box;&#125;.box img&#123; width:100%; height:auto;&#125; js瀑布流的重点部分就在js啦。 首先我们写一个创建节点的函数，用于创建.pin、.box和img，createDom传入父节点和img的src。1234567891011function createDom(obj,src)&#123; var oDiv = document.createElement('div'); oDiv.className = 'pin'; var oBox = document.createElement('div'); oBox.className = 'box'; var oImg = document.createElement('img'); oImg.src = './images/'+src; oBox.appendChild(oImg); oDiv.appendChild(oBox); obj.appendChild(oDiv); &#125; 此时我们的页面上还空无一物呢，这时需要我们模拟后端数据，遍历json调用createDom生成dom节点。12345678var oParent = document.getElementById('main'); var dataInt = []; for(var i=0;i&lt;98;i++)&#123; dataInt.push(&#123;'src':i+'.jpg'&#125;); if(i&lt;50)&#123; createDom(oParent,dataInt[i].src); &#125; &#125; 此时样式大致是这样的 然后我们再写一个定位的函数,让其一一队列排齐。由于是等宽的，我们获取其中一个.pin的宽度，然后让可视窗口宽度除以这个宽度，通过向下取整获得一行能放下.pin的个数。用.pin的宽度*个数得到它父容器应该有的宽度赋给父容器，然后让其居中显示，此时整体就居中了。我们再把所有的.pin遍历一遍，先把第一行的所有.pin的高度装在pinHarr数组里面。由于瀑布流是一一对齐的，每一行的第一个都是在最矮的那一列下面。所以第二行的第一个.pin应该在它的上一行最矮的那个.pin下面，所以不是第一行的话，我们给其全部绝对定位，我们就找到第一行中.pin的最小高度，取得它的索引，这样就得到最矮的那个.pin，我们取得它的高度和索引，把第二行的这个.pin的top赋值第一行中.pin最小高度，left赋值第一行最矮的.pin的索引*.pin的宽度，这样第二行的第一个就在第一行的最矮的那个.pin下面且对齐。最后我们把pinHarr中最小的那个高度换成最小高度加上新增的这个.pin高度（简单来说就是列高），此时最小高度变化了，我们下一次还是找最小高度放.pin，以此类推，每次放置.pin都是找最矮那一列放置。这样就实现了等宽不等高的对其布局了。12345678910111213141516171819202122function waterfall(parent,pin)&#123; var aPin = parent.querySelectorAll(pin); var iPiw = aPin[0].offsetWidth; var num = Math.floor(document.documentElement.clientWidth/iPiw); parent.style.cssText = 'width:'+num*iPiw+'px;margin:0 auto;'; var pinHarr = []; aPin.forEach(function(el,index)&#123; var pinH = el.offsetHeight; if(index&lt;num)&#123; pinHarr[index] = pinH; &#125;else&#123; var minH = Math.min.apply(null,pinHarr); var minindex = pinHarr.findIndex(function(num)&#123; return minH===num; &#125;); el.style.position = 'absolute'; el.style.left = iPiw*minindex +'px'; el.style.top = minH+'px'; pinHarr[minindex] = minH+el.offsetHeight; &#125; &#125;); &#125; 接下来等页面生成的最后一个img加载出来后我们调用这个函数，布局就完成了。123oParent.getElementsByClassName('pin')[49].getElementsByTagName('img')[0].onload = function()&#123; waterfall(oParent,'.pin'); &#125; 当页面滚动到底部时，我们还要让其生成新的dom，将其放在底部。我们先写一个判断函数，判断滚动条滚动时到达底部没有，没有就返回false，有就返回true。1234567function isBottom()&#123; var aPin = oParent.querySelectorAll('.pin'); var lastPinh = aPin[aPin.length-1].offsetTop+Math.floor(aPin[aPin.length-1].offsetHeight/2); var Sh = document.documentElement.scrollTop||document.body.scrollTop; var Dh = document.documentElement.clientHeight; return lastPinh&lt;Sh+Dh?true:false;&#125; 最后我们添加滚动事件，当到达底部时，我们遍历json，用createDom生成dom添加到#main底部，然后调用waterfall，让其让其一一队列排齐。12345678window.onscroll = function()&#123; if(isBottom())&#123; dataInt.forEach(function(val)&#123; createDom(oParent,val.src); &#125;); waterfall(oParent,'.pin'); &#125;&#125; 这样，一个等宽不等高的无限加载的瀑布流就实现了。效果如下： 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>小实例</tag>
        <tag>瀑布流</tag>
        <tag>无限加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算器小实例]]></title>
    <url>%2F2017%2F11%2F13%2FCalculator%2F</url>
    <content type="text"><![CDATA[最近在学react，没啥时间更新博客，等有空的时候把react基础写一写，react写法还是挺有意思的。这个实例没啥可说的，就是一个小实例而已，js实现最简单的计算器功能。当然原理很简单的，就是通过eval()可以计算字符串的特性实现字符串的运算，当然eval()还是少用为好，它的可读性非常差，不好再做优化和编译。 关键js代码12345678910111213141516171819202122232425262728293031var btns = document.querySelectorAll('button.btns'),text = document.querySelectorAll('.box p'),arr = [],Result;[].slice.call(btns).forEach(function(element) &#123; element.onclick = function()&#123; if(this.value === '=')&#123; try&#123; Result = eval('('+arr.join('')+')'); &#125;catch(e)&#123; Result = 'error'; &#125; arr = [Result]; text[1].innerText = Result; &#125;else&#123; text[0].innerText = ''; if(this.value === 'C')&#123; arr = []; return; &#125; if(this.value === 'Back')&#123; arr.pop(); &#125;else&#123; arr.push(this.value); &#125; arr.map(function(num)&#123; text[0].innerText += num; &#125;); &#125; &#125;&#125;); 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>计算器</tag>
        <tag>小实例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽小实例]]></title>
    <url>%2F2017%2F11%2F01%2Fdrag%2F</url>
    <content type="text"><![CDATA[在日常业务中有很多时候会用到拖拽，比如弹窗什么的，还有一些导航什么的拖动组成自己喜欢的导航。今天就写了两个小例子带大家了解PC端和移动端的拖拽是怎么实现的。 PC端拖拽pc端拖动主要是onmouse事件，当你鼠标对拖动目标点下时触发拖动目标的onmousedown事件，此时记录下鼠标点击的位置坐标和拖动目标的右上角坐标，得到二者之差，鼠标点下并且拖动触发document的onmousemove事件，获得不断移动的鼠标位置坐标，再减去之前得到的差值，把得到的Y轴移动值赋给top，X轴移动值赋给left；当鼠标松开时触发onmouseup事件，此时销毁document.onmousemove和拖动目标的onmousemove和事件，一个简单的拖拽就完成了。注意一下，当拖动是会有默认事件发生，比如往下拖动，如果有滚动条的话，会使滚动条滚动，这时需要阻止一下默认事件，event.preventDefault();当然，如果你要限制范围的话，可以在onmousemove中吧Y轴移动值和X轴移动值用判断限制一下，我限制的是不能超过文档窗口，有兴趣可以改一下。1234567891011121314151617181920212223242526272829303132function touch(id)&#123; var obj = document.getElementById(id); obj.onmousedown = function(event)&#123; var disX = event.pageX - obj.offsetLeft; var disY = event.pageY - obj.offsetTop; var W = document.documentElement.clientWidth-obj.offsetWidth; var H = document.documentElement.clientHeight-obj.offsetHeight; document.onmousemove = function(event)&#123; event.preventDefault(); var l = event.pageX - disX; var t = event.pageY - disY; if(l&lt;0)&#123; l = 0; &#125; if(l&gt;W)&#123; l = W ; &#125; if(t&lt;0)&#123; t = 0; &#125; if(t&gt;H)&#123; t = H; &#125; obj.style.top = t+ 'px'; obj.style.left = l+'px'; &#125; obj.onmouseup = function()&#123; document.onmousemove = null; obj.onmouseup = null; &#125; &#125; &#125;; 移动端拖拽移动端的拖拽是由touch事件完成的，和PC的onmouse事件大致一样，touchstart是手指按下，可以通过event.targetTouches.length获得有多少手指按下，一般拖动一根手指，于是当event.targetTouches.length == 1时才能触发拖拽事件，event.targetTouches[0]相当于鼠标的event，通过这个可以获取手指按下的坐标，其余的大致和PC差不多。123456789101112131415161718192021222324252627282930313233343536373839function touch(id)&#123; var obj = document.getElementById(id); obj.addEventListener('touchstart', function(event) &#123; if (event.targetTouches.length == 1) &#123; var touch = event.targetTouches[0]; var disX=touch.pageX-obj.offsetLeft; var disY=touch.pageY-obj.offsetTop; var W = document.documentElement.clientWidth-obj.offsetWidth; var H = document.documentElement.clientHeight-obj.offsetHeight; obj.addEventListener('touchmove',move); function move(event)&#123; event.preventDefault(); var touch2=event.targetTouches[0]; var l=touch2.pageX-disX; var t=touch2.pageY-disY; if(l&lt;0)&#123; l=0; &#125;; if(l&gt;W)&#123; l=W; &#125;; if(t&lt;0)&#123; t=0; &#125;; if(t&gt;H)&#123; t=H; &#125;; obj.style.left=l+'px'; obj.style.top=t+'px'; &#125;; obj.addEventListener('touchend',chend); function chend(event)&#123; obj.removeEventListener('touchmove',move); obj.removeEventListener('touchend',chend); &#125;; &#125;; &#125;, false); &#125;; 不过有个地方要注意一下，移动端如果使用event.preventDefault();阻止默认事件的话，可能会对流畅度有点影响，如果你想应用到高级的浏览器上的话，就不要使用event.preventDefault();了，推荐的做法是用css中的touch-action来阻止默认事件，touch-action:none使触控事件发生在元素上时，不进行任何操作。也就是当touchstart发生时让html的touch-action为none，拖动完成touchend时，把html的touch-action改成auto就行了。1234567891011121314151617181920212223242526272829303132333435363738function touch(id)&#123; var obj = document.getElementById(id); obj.addEventListener('touchstart', function(event) &#123; if (event.targetTouches.length == 1) &#123; var touch = event.targetTouches[0]; var disX=touch.pageX-obj.offsetLeft; var disY=touch.pageY-obj.offsetTop; obj.addEventListener('touchmove',move); function move(event)&#123; document.documentElement.style.touchAction = 'none'; var touch2=event.targetTouches[0]; var l=touch2.pageX-disX; var t=touch2.pageY-disY; if(l&lt;0)&#123; l=0; &#125;; if(l&gt;document.documentElement.clientWidth-obj.offsetWidth)&#123; l=document.documentElement.clientWidth-obj.offsetWidth &#125;; if(t&lt;0)&#123; t=0; &#125;; if(t&gt;document.documentElement.clientHeight-obj.offsetHeight)&#123; t=document.documentElement.clientHeight-obj.offsetHeight; &#125;; obj.style.left=l+'px'; obj.style.top=t+'px'; &#125;; obj.addEventListener('touchend',chend); function chend(event)&#123; document.documentElement.style.touchAction = 'auto'; obj.removeEventListener('touchmove',move); obj.removeEventListener('touchend',chend); &#125;; &#125;; &#125;, false); &#125;; 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小实例</tag>
        <tag>拖拽</tag>
        <tag>touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片加载]]></title>
    <url>%2F2017%2F10%2F27%2Fcomplete%2F</url>
    <content type="text"><![CDATA[图片懒加载技术相信大家再熟悉不过了，当网站中用到大量图片时回事网站打开时加载过慢，用户体验不好。用户其实看到的是可视区域，可视区域下面的图片什么的可以不用加载，当用户滚动滚动条要看到还没加载的图片时，在让其进行加载。所谓懒加载，就是把img的src放在一个自定义属性中，src为空，当触发某个事件时把自定义属性的值赋给src。1234&lt;img data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1509098785051&amp;di=0cdd1c1cb8314d1fe3c460f3e13ece59&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.niutuku.com%2Fdesk%2F1207%2F1052%2Fntk121408.jpg" alt="" class="myimg" /&gt;var img = document.getElementsByTagName('img')[0];img.src = img.getAttribute("data-src"); 当然，一些小图片可以这样做，因为加载快嘛，一瞬间就完成了，但是网络比较慢的时候加载一些大图片时，就不太好了。一般懒加载默认有个默认的显示图片，但是直接替换的话，如果加载慢的话图片一下没加载出来就会显示一片空白，这样不太好，应该做到替换时图片直接显示出来，图片没加载完成还是显示的默认图片。这就要用到我们今天所说的东西了，判断图片加载完成后触发的事件。判断图片加载完成一般有三种方法 一、load事件123456var img = document.getElementsByTagName('img')[0];var Img = new Image();Img.src = img.getAttribute("data-src");Img.onload = function ()&#123;&#125; 简单粗暴，基本上所有浏览器都支持，但是有一个问题，在IE、Opera等浏览器中第一次加载是正常的，但是同一张图片再次加载时不会触发onload事件了，IE是根据图片是否显示过来判断，就是说当加载的图片显示出来后就不在执行onload事件了。 二、onreadystatechange事件12345678var img = document.getElementsByTagName('img')[0];var Img = new Image();Img.src = img.getAttribute("data-src");Img.onreadystatechange = function ()&#123; if(Img.readyState=="complete"||Img.readyState=="loaded")&#123;&#125;&#125; 在ie下，img对象与xhr对象一样具有onreadystatechange事件，可以通过该事件判断图片是否加载完成，ie特有的，其他浏览器不支持。且问题和上面问题一样。 三、img的complete属性complete 属性可返回浏览器是否已完成对图像的加载，如果加载完成，则返回 true，否则返回 fasle，基本所有浏览器都支持，且不会有上面的问题。我们可以用其特性，做一个定时器，查看其是否加载完成，完成加载后执行一个回调函数。1234567891011121314151617181920212223242526272829303132333435&lt;button onclick="loadImage(document.getElementsByTagName('img'),imgLoaded,allimgLoaded)"&gt;加载&lt;/button&gt;&lt;img data-src="http://ouzdb04w7.bkt.clouddn.com/image/2017/10/27/timg1.jpg" src="" alt="" class="myimg" /&gt;&lt;img data-src="http://ouzdb04w7.bkt.clouddn.com/image/2017/10/27/timg2.jpg" src="" alt="" class="myimg" /&gt;&lt;img data-src="http://ouzdb04w7.bkt.clouddn.com/image/2017/10/27/timg3.jpg" src="" alt="" class="myimg"/&gt; function loadImage(objarr,callback,allcallback)&#123; var timer = null; var i = 0; var len = objarr.length; var load; load = function(i)&#123; if(i&lt;len)&#123; var img = new Image(); img.src = objarr[i].getAttribute("data-src"); timer = setInterval(function()&#123; if(img.complete)&#123; clearInterval(timer); callback(objarr[i++],img); load(i); &#125; &#125;,80); &#125;else&#123; allcallback(); &#125; &#125;; load(0);&#125;function imgLoaded(obj,img)&#123; obj.src = img.src; console.log(img.width);&#125;function allimgLoaded()&#123; alert("图片全部加载完成");&#125; ok，上面将一堆图片的data-src链接放在了src中，图片都是瞬间出现，而不是慢慢加载出来的。本文代码地址:链接;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小实例</tag>
        <tag>图片替换</tag>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-背景裁剪]]></title>
    <url>%2F2017%2F10%2F26%2Fbackground-clip%2F</url>
    <content type="text"><![CDATA[最近一直忙着看ES6（懒），好久都没更新博客（不想写），难得下午抽空写写。好了，今天的是文字对背景图片的裁剪，以及一些衍生的小东西。 background-clip:background-clip 属性规定背景的绘制区域。其值主要有四个1234background-clip: border-box;background-clip: padding-box;background-clip: content-box;background-clip: text; 顾名思义剪切掉边框的背景，剪切掉外边距的背景，剪切掉内容的背景，剪切掉文字外背景当然最后一个比较特殊，需要比较高级的浏览器才能看到。 -webkit-text-fill-color:检索或设置对象中的文字填充颜色，通过text-fill-color属性，可以做出一些例如渐变文字和镂空文字的效果。上面的配合-webkit-text-fill-color: transparent;属性可以让文字的填充色变成透明，透过文字看到背景。 background-position:background-position 属性设置背景图像的起始位置。这三者结合起来会产生什么效果呢？（请用谷歌浏览器观看）12345678910111213141516171819.text2 &#123; width: 720px; background-image: -webkit-linear-gradient(top, #fc0, #f30 50%, #c00 51%, #600); -webkit-background-clip: text; font-size: 80px; -webkit-text-fill-color: transparent; font-weight: bold; background-repeat: no-repeat; background-position: -800px 0; animation: loop 10s linear infinite;&#125;@keyframes loop &#123; 0% &#123; background-position: -800px 0; &#125; 100% &#123; background-position: -0 0; &#125;&#125; 很像卡拉OK的效果，是不是很酷呀。 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>背景裁剪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传那些事-总结篇]]></title>
    <url>%2F2017%2F09%2F21%2Fimgfile3%2F</url>
    <content type="text"><![CDATA[好了，总结篇终于开工了，这次来说说关于上传的一些琐碎事情。 1.file input的美化file input 好用是好用但是论起颜值来说差得不是一点半点，怎么能让这玩意儿拉低我们写好的页面颜值呢(ง •̀_•́)ง，来整整容吧，其实这个东西实现起来也很简单的首先我们把这个上传的input用display: none;隐藏掉，然后发挥自己力量写个高颜值的上传按钮，给这个按钮添加点击事件，点击的时候让上传input触发点击，ok，美化工作就完成了。1234567&lt;input type="file" id="file" style="display: none;"/&gt;&lt;button class="btn" onclick="upimg()"&gt;上传&lt;/button&gt;var myfile = document.getElementById('file');function upimg()&#123; myfile.click();&#125; 2.上传筛选很多时候在上传东西的时候都要进行上传筛选的工作，避免用户把什么乱七八糟的东西都往后台扔，其实input有 accept 这个属性来进行提交文件类型的筛选的。1&lt;input type="file" name="pic" id="pic" accept="image/gif, image/jpeg" /&gt; //选择git和jpg图片上传 但是这玩意儿有点兼容问题，其筛选还可以选择全部文件，并不能达到筛选的目的。上文说到我们用数组装用户要上传的图片，那么筛选就可以在数组push的时候进行了。这样凡是验证不通过的filearr都不会push进去，也就提交不了了。 123456789101112var filearr = [];var myfile = document.getElementById('file');myfile.onchange = function()&#123; var files = this.files; for(var i = 0;i&lt;files.length;i++)&#123; if(!(files[i].type.indexOf('image')==0 &amp;&amp; files[i].type &amp;&amp; /\.(?:jpg|png|gif)$/.test(files[i].name)) )&#123; console.log('图片只能是jpg,gif,png'); //上传其余文件的验证根据情况自己写 continue; &#125;; filearr.push(files[i]); &#125;&#125; 3.上传进度条在进行上传时有时候会有进度显示的需求，在XMLHttpRequest对象发出的HTTP请求时可以绑定progress事件，来获得传输的数据进度。123456789101112131415161718192021222324&lt;div class="progress"&gt; &lt;div id="progressbar" style="width:0%"&gt; 0% &lt;/div&gt;&lt;/div&gt;var request = new XMLHttpRequest(); request.open("POST", "1.php",true); request.onreadystatechange = function()&#123; if(request.readyState==4)&#123; &#125; &#125;; request.upload.addEventListener('progress',progress, false); //绑定progress事件 request.send(formData); var progressbar = document.getElementById('progressbar'); function progress(e)&#123; if(e.lengthComputable)&#123; var percentComplete = Math.round(e.loaded/ e.total * 100 ); console.log(percentComplete); progressbar.style.width = percentComplete+"%"; progressbar.innerText = percentComplete+"%"; &#125; &#125; 至于进度条样式什么的靠自己发挥啦。 4.富文本编辑器问题有很多富文本编辑器都带有文件上传的功能，但是使用是很多时候都有点小问题，在用谷哥浏览器时，点击上传按钮后很久图片选择的弹窗才出现。其原因就是上传的input设置了多个筛选的accept，比如image/*和image/svg+xml，这会导致谷哥浏览器打开文件选择弹窗特别慢。解决办法 :涉及多个文件验证的用accept=&quot;image/jpeg, image/jpg, image/png, image/gif&quot;，避免使用类似image/*和image/svg+xml多个文件同时验证的写法，可以修改富文本js源码，或者富文本加载完成后用file.setAttribute(‘accept’,XXX)覆盖掉。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>图片上传</tag>
        <tag>上传进度</tag>
        <tag>上传美化</tag>
        <tag>上传筛选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传那些事-图片上传篇]]></title>
    <url>%2F2017%2F09%2F09%2Fimgfile2%2F</url>
    <content type="text"><![CDATA[上次说完了图片上传预览，使用form提交就可以把图片进行提交了，但是在现实中这样的操作往往满足不了用户需求，一般在进行上传操作时可能会进行图片的多次重新选择和增删所选择的图片，这时用form提交就实现不了。 这时就该我们本篇的主角闪亮登场了：FormData。W3C在2008年提出XMLHttpRequest Level 2的草案中改进了XMLHttpRequest对象，在新版本的一些功能中就有FormData。利用FormData对象,我们可以模拟表单操作，然后通过XMLHttpRequest的send()方法来异步提交这个表单，发送FormData对象，这与form提交网页表单的效果完全一样，这个改进使得可以通过新版XMLHttpRequest对象上传文件，使得无刷新上传文件成为了可能。1.FormData创建一个FormData对象，可以直接通过new FormData()创建一个FormData空对象：1var formData = new FormData(); 当然，想要构造一个包含Form表单数据的FormData对象时，也可以通过HTML表单创建FormData对象，需要在创建FormData对象时指定表单的元素,这样做在发送数据时会将你的form表单的数据添加到formData中一起发送出去。12var myform = document.querySelector("form");var formData = new FormData(myform); 2.FormData操作方法FormData通过append(name, value,filename)来添加数据，其实就是类似于使用键值对添加数据，如果添加的name不存在则会新增一条数据，如果name已存在，则value将添加到数组的末尾，类似于[‘a1’,’a2’]。filename是可选的，这是指定文件的文件名，当value参数被指定为一个Blob对象或者一个File对象时，该文件名会被发送到服务器上，对于Blob对象来说，这个值默认为blob。12345formData.append("a1", "aa");formData.append("a1", "bb");formData.append("a1", "cc");formData.getAll("a1"); // ["aa","bb","cc"] set(name, value) 方法会对 FormData 对象里的某个 name 设置一个新的value，如果该 name 不存在，则添加。123formData.append("a1", "aa");formData.set("a1","bb");formData.get("a1"); // "bb" delete() 方法 会从 FormData 对象中删除指定 name 和它对应的 value。123formData.append("a1", "aa");formData.delete("a1");formData.get("a1"); ////null get()和getAll(),get()方法用于返回FormData对象中和指定的键关联的第一个值，getAll()方法会返回该 FormData 对象指定键的所有值。123456formData.append("a1", "aa");formData.append("a1", "bb");formData.append("a1", "cc");formData.get("a1"); // "aa"formData.getAll("a1"); // ["aa","bb","cc"] has()方法会返回一个布尔值，表示该FormData对象是否含有某个name 。12formData.append("a1", "aa");formData.has("a1"); //true 当然还有遍历，entries()遍历所有的数据，keys()遍历所有key，values()遍历所有value,用法都一样12345formData.append('a', 'aa');formData.append('b', 'bb');for(var pair of formData.entries()) &#123; console.log(pair[0]+ ', '+ pair[1]); //a,aa &#125; //b,bb 好了，废话说了这么多，该进入正题了。想要对用户选择的图片进行准确的上传，用什么方式最简单呢？当然是用数组进行操作啦。首先来个上传多文件上传input1&lt;input type="file" class="hidden" id="file" multiple="multiple"/&gt; 然后声明一个空数组，在onchang事件发生时把用户要上传的图片装进去123456789var filearr = [];var myfile = document.getElementById('file');myfile.onchange = function()&#123; var files = this.files; for(var i = 0;i&lt;files.length;i++)&#123; filearr.push(files[i]); //这里就进行添加图片的预览操作 &#125;&#125; 当用户删除图片时(.close是删除按钮，closeli()是.close点击时执行的函数)，filearr也进行删除，预览用的图片也要干掉，当然数据结构不同时自行处理12345678910111213141516171819&lt;li&gt;&lt;img src=""&gt;&lt;span class="close" onclick="closeli(this)"&gt;×&lt;/span&gt;&lt;/li&gt;var closes = document.getElementsByClassName("close");function closeli(obj)&#123; var closes = document.getElementsByClassName("close"); [].slice.call(closes).forEach(function(el,index)&#123; if(obj === closes[index])&#123; filearr.splice(index,1); &#125;; &#125;); parents(obj,'li').remove();&#125;function parents(obj,node)&#123; if(obj.parentNode.tagName==node.toUpperCase())&#123; return obj.parentNode; &#125;else&#123; return parents(obj.parentNode,node); &#125; &#125; 点击上传时，如果要连form表单中的数据一起提交就把form传入FormData中，否则可以创建一个FormData空对象提交，当然你也可以通过append添加自定义数据。12345678910111213141516function sub()&#123; var myform = document.querySelector("form"); var formData = new FormData(myform); for(var i =0;i&lt;filearr.length;i++)&#123; //提交时，我们把filearr中的数据遍历一遍 formData.append("upfile[]", filearr[i]); //用append添加到formData中，就得用户最终要提交的图片了 &#125;; formData.append("aaa", 111); var request = new XMLHttpRequest(); request.open("POST", "1.php",true); request.onreadystatechange = function()&#123; if(request.readyState==4)&#123; &#125; &#125;; //注意一定不要设置request.setRequestHeader request.send(formData);&#125; 可以用1.php看看上传的数据1234&lt;?phpvar_dump($_FILES); //上传的图片var_dump($_REQUEST); //上传的数据?&gt; 当然，你如果用的是jq的话，ajax得改一改。processData设置为false，因为data值是FormData对象，不需要对数据做处理；contentType设置为false，因为上传的是FormData对象，不需要设置内容类型；当然上传文件不需要缓存，cache:false。 12345678910function sub()&#123; $.ajax(&#123; url: "1.php", type: "POST", data:formData, cache:false, //不设置缓存 processData: false, // 不处理数据 contentType: false // 不设置内容类型 &#125;); &#125; 由于本文在github上的，做不了服务器演示，故不能成功提交，想看提交数据的自行打开浏览器的notwork查看：ok，图片上传就算是完成了，当然本人原创内容，能力有限，才疏学浅，有错误的地方望大家指正。下次更新文件上传时的一些杂项，比如美化上传按钮，显示上传进度什么的。请期待：请期待:图片上传那些事-总结篇。本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>图片上传</tag>
        <tag>图片预览</tag>
        <tag>图片批量上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传那些事-图片预览篇]]></title>
    <url>%2F2017%2F09%2F06%2Fimgfile1%2F</url>
    <content type="text"><![CDATA[在前端工作中，有一些小功能是大家经常遇到的，图片的上传就是经常遇到的功能之一，平时图片上传有很多的需求，比如图片预览，批量上传，有些还要有上传进度，本文将介绍如何实现图片的批量上传和删除以及预览。以前的浏览器由于安全问题和兼容问题，实现不了本地图片信息的读取预览，只能选择一张就上传一张图片到服务器，然后服务器返回图片地址从而实现图片的预览，但是随着老的浏览器(ie)的逐渐淘汰，以及各个浏览器标准的统一，图片的预览也变得十分简单了。图片预览有两种方法可以实现： 1.文件读取API-FileReader对象，它可以允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据，它的readAsDataURL方法将文件读取为 DataURL，在读取完成时调用如果设置onload事件，则调用之，在onload里能获得result属性，它包含一个data: URL格式的字符串以表示所读取文件的内容。12345678910111213141516var myfile = document.getElementById('file'); var List = document.getElementsByClassName('list')[0];myfile.onchange = function()&#123; var files = this.files; if(!files)return; console.log(files); for(var i = 0;i&lt;files.length;i++)&#123; var oFReader = new FileReader(); oFReader.readAsDataURL(files[i]); oFReader.onload = function (oFREvent) &#123; console.log(oFReader); var oLi = '&lt;li&gt;&lt;img src="'+oFREvent.target.result+'"&gt;&lt;span class="close" onclick="closeli(this)" &gt;&amp;times;&lt;/span&gt;&lt;/li&gt;'; List.innerHTML+=oLi; &#125;; &#125; &#125; 实际上这种方法就是将图片解析成base64编码，然后将这个编码传给img的src，使图片通过变成base64的方式能够显示在页面上。如下: 是不是简单的实现了图片的预览了，当然这种方法不是特别的好，因为base64是用于处理那些简单的图片的，一般稍微大一点的图片会使base64特别大，如图:那么第二种方法闪亮登场了。 2.URL.createObjectURL，URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。通俗来说就是URL.createObjectURL()方法会根据传入的参数创建一个指向该参数对象的URL. 这个URL的生命仅存在于它被创建的这个文档里. 新的对象URL指向执行的File对象或者是Blob对象，通过给img的src赋值URL.createObjectURL(File)就能让其显示在页面上。1234567891011var myfile = document.getElementById('file'); var List = document.getElementsByClassName('list')[0]; myfile.onchange = function()&#123; var files = this.files; if(!files)return; console.log(files); for(var i = 0;i&lt;files.length;i++)&#123; var oLi = '&lt;li&gt;&lt;img src="'+URL.createObjectURL(files[i])+'"&gt;&lt;span class="close" onclick="closeli(this)" &gt;&amp;times;&lt;/span&gt;&lt;/li&gt;'; List.innerHTML+=oLi; &#125; &#125; 这种方法简单多了，而且reatObjectURL可以有更好的性能，在处理上比用FileReader对象读取预览的更快，url十分简洁，完胜base64。] 好了，到这里开始详细讲解多图预览了，首先要有一个上传input,既然要多图上传，就要设置multiple。1&lt;input type="file" class="hidden" id="file" multiple="multiple"/&gt; 然后我们给他设置一个onchang事件，监听上传文件都选择，通过其files属性得到FileList对象，可以通过这个对象访问到用户所选择的文件，这个FileList是一个数组，如果是单文件上传，要获取其File就是files[0]或者files.item(0)。多文件上传的话，我们把得到的FileList对象循环一遍，获得每个文件的File，将这个File通过FileReader或createObjectURL进行处理，得到想要的预览url路径，然后创建一个img，将这个url路径赋给img的src。123456789var myfile = document.getElementById('file'); myfile.onchange = function()&#123; var files = this.files; //单文件就是this.files[0]，不用做for循环 if(!files)return; console.log(files); for(var i = 0;i&lt;files.length;i++)&#123; console.log(files[i]); &#125;&#125; ok了，图片多图上传预览就完成了，但是实际情况中还要涉及到图片的多次重新选择和删除所选择的图片，那么该如何进行操作呢？我将在下篇博文中讲解，请期待:图片上传那些事-图片上传篇。本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>图片上传</tag>
        <tag>图片预览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Circle 进度环--css篇]]></title>
    <url>%2F2017%2F08%2F31%2Fring%2F</url>
    <content type="text"><![CDATA[网上有各种进度，进度条啊，进度环，进度条做起来简单，可是有很多时候需要的是进度环，本篇是用css3的效果结合js完成进度环的。废话不多说了，上结构html:12345&lt;div class="loading"&gt; &lt;div class="left"&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div class="progress"&gt;&lt;span&gt;0&lt;/span&gt;%&lt;/div&gt;&lt;/div&gt; 大概结构是这样的（图烂勿怪，我画图烂的有一手，(ノへ￣、)）css:12345678910111213141516171819202122232425262728293031323334353637383940414243.loading&#123; margin: 10px auto; width: 150px; height: 150px; position: relative; background-color: #FFF;&#125;.progress&#123; position: absolute; top: 50%; left: 50%; width: 130px; height: 130px; transform: translate(-50%,-50%); color: red; line-height: 130px; text-align: center; background-color: #FFF; border-radius: 50%;&#125;.left,.right&#123; float: left; width: 50%; height: 100%; position: relative; overflow: hidden;&#125;.left span,.right span&#123; display: block; position: absolute; width: 100%; height: 100%; background-color: red; transition: all 0.4s;&#125;.left span&#123; border-radius:150px 0 0 150px; transform-origin: right;&#125;.right span&#123; border-radius:0 150px 150px 0; transform-origin: left;&#125; 主要的原理就是让.left，.right的span通过transform: rotateZ旋转角度，一开始.left span旋转180度到.right那边，然后通过overflow: hidden使其超过的隐藏，此时.left span完全在.left外面，完全隐藏了，然后通过减小.left span的旋转角度，让其在.left中显现出来，.right span同理。其实本来显示的会是一个扇形，但是由于有.progress这个白色的圆覆盖在.loading上面，就变成了圆环。 实现效果如下，可以在输入框输入：（本人对颜色极其不敏感，红色不好看就不要吐槽了，自己改） 本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>小实例</tag>
        <tag>css3</tag>
        <tag>进度环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垂直居中-文本篇]]></title>
    <url>%2F2017%2F08%2F26%2Fvertical%2F</url>
    <content type="text"><![CDATA[拖延症太强，每次想写点东西的时候总是会想着明天写，今天强行克服了，总算是动工了，好吧，我的第一篇技术博客。说真的css这玩意儿，很多人认为写写就行了，但在我看来这东西的复杂程度不下于js，写好真的是很难很难，各种布局都有不同的写法，写这个的原因是把常写的东西总结一下，希望给大家参考参考，同时也是对我自己的一个学习总结吧，见识不足，还请谅解。 html统一样式123&lt;div class="text"&gt; &lt;span class="pox"&gt;&lt;/span&gt;&lt;/div&gt; 知道高度1.绝对定位absolute12345678910111213//父标签用相对定位 .text1&#123; position: relative; height: 400px;&#125;//子标签用绝对定位，然后top:50%;margin-top:负的高度的一半，ok，垂直居中达成.pox1&#123; line-height: 30px; position: absolute; top: 50%; margin-top: -30px;&#125; 2.单行文本,这个简单12345//父标签行高=父标签行高度，ok了; .text4&#123; line-height:400px; height: 400px; &#125; 不知道高度1.table-cell,把div作为一个表格单元格使用,单元格垂直居中？so easy,用vertical-align: middle.1234567891011父标签 .text2&#123; display: table-cell; vertical-align: middle; height: 400px; &#125;子标签.pox2&#123; display: inline-block;&#125; 2.table,原理同上1234567891011父标签 .text3&#123; display: table; height: 400px; &#125;子标签.pox3&#123; display: table-cell; vertical-align: middle; &#125; 3.妙用:after占位居中,让:after占据全部高度,然后使用vertical-align:middle与:after竖直居中对齐,由于:after宽为0,看不见,就表现为pox5垂直居中了1234567891011121314151617父标签 .text5&#123; height: 400px;&#125;.text5:after&#123; content:''; width:0; height:100%; display:inline-block; vertical-align:middle;&#125;子标签.pox5&#123; vertical-align:middle; display:inline-block;&#125; 4.display:flex,这玩儿说起来就多了,弹性盒子布局,布局爽到飞起，就是兼容性有点问题，不过加上-webkit-后能适应绝大部分游览器1234567891011121314父标签 .text6&#123; display: -webkit-flex; display: flex; height: 400px; -webkit-align-items: center; align-items: center;&#125; 子标签.pox6&#123; -webkit-flex: 1; flex: 1;&#125; 5.display:-webkit-box,这个是flex的旧版本,同上123456父标签 .text7&#123; display: -webkit-box; -webkit-box-align:center; height: 400px;&#125; 6.transform,利用translateY(-50%);translateY(-50%)其实就是垂直向上偏移物体自身高度的一半,效果和margin-top:负的高度的一半差不多,不过不需要知道具体高度,浏览器自己计算.12345678910111213父标签 .text8&#123; position: relative; height: 400px;&#125;字标签.pox8&#123; position: absolute; top: 50%; transform: translateY(-50%); left: 0;&#125; css的妙处就是可以用很多种方法实现同一个效果,本文代码地址:链接]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>那些年我们常写的css</tag>
        <tag>垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈岱孙]]></title>
    <url>%2F2017%2F08%2F22%2Fcelebrity%2F</url>
    <content type="text"><![CDATA[有许多文人志士埋没在历史的尘埃之中，但是我希望其精神能让人见到，其事迹能让人知晓。一日一度，一生一事。云山苍苍，江水泱泱，先生之风，山高水长!在北大燕南园55号门前，立有一樽老人的铜像。老人手拄拐杖，端坐凝神，慈蔼的面目于平和中带着守护的神光。铜像下方，刻着老人生前常说的一句话：“我这辈子只做了一件事，教书。”这位执教了70年近百岁的老人，80岁还在给本科生上课，90岁还在带博士生，他就是经济学大师，陈岱孙。 01冥冥中有所注定似的，陈岱孙先生出生于农历闰八月二十七日，这一天恰恰是孔子的诞辰。1900年10月20日，陈岱孙先生出生于福州闽侯县。在福建当地，螺江陈氏乃是簪缨世家。有官至刑部尚书的陈若霖，也有海军中将陈庆甲。先生的伯祖父陈宝琛更是溥仪的帝师，内外亲戚里还有清政府驻外公使，位高权重。陈岱孙可以说是名正言顺的贵族子弟。深厚的家学渊源，陈岱孙自幼耳濡目染，恰逢新旧时代变幻，又受到西学影响。 宣统皇帝退位后，旧教育弊端积显，除了旧式私塾，父母还专门，请老师教他英文、数学。15岁陈岱孙考上鹤龄英华学校时，已经能说一口流利的英语。由于家学甚厚，陈岱孙成了“专读生”，免修各年级中文课程，专修外文课程。结果陈岱孙只花了两年时间，就把四年课程全部修完。1918年初，他考入清华大学留美预科班，与同时代的清华学子一样，两年后赴美留学。在上海考清华插班生时，陈岱孙曾去黄浦公园游玩，兴致勃勃来到门前，却发现大门上挂着牌子：华人不得入内。“不管你是不是租界，在我们中国人的土地上，却不允许我们自己进去，实在是欺人太甚！”陈岱孙满腔激愤，深感中华民族的屈辱，回去之后加倍努力读书，誓要振兴中华。 到美国之后，陈岱孙研读经济学，本就智商超群，较之一般学生，又不知刻苦多少倍。1922年，陈岱孙取得了，威斯康辛大学学士学位，还拿到了美国大学生最高荣誉——金钥匙奖。之后他又到哈佛攻读博士，整整四年，陈岱孙在图书馆专用的小隔间里，闭门读书，废寝忘食，最终以一纸论文通过答辩，顺利拿到博士学位。毕业之后，他又到英法意做短期考察。1927年，陈岱孙回到了阔别多年的祖国，成为清华经济系教授与系主任，次年，又兼任清华大学法学院院长，也是同时期清华校园中最年轻的院长。 先生在清华任教之初虽然在美国读书时，陈岱孙两耳不闻窗外事，几乎天天封闭在小隔间里用功。若凭此以为他只是学霸，那就大错特错了。在清华校园里，年轻的陈岱孙，向来有男神美誉。30岁不到的他，既有中国学者之风度，又有英美绅士的派头。一米八几的个头，经常是一身笔挺的西服，衣领、袖口妥帖平整，整个人不苟言笑。即便是平常衣衫，也能被他穿出一身别样风度。虽然他的嘴稍微有点歪，下唇有点儿地包天，然而脸部轮廓分明，透出一种刚强坚毅的气质，无论往哪儿一站，简直如同一樽铜像，成为人们目光的焦点。这份气宇轩昂一直保持到他的晚年，1988年墨西哥总统访问北大，陈岱孙先生一身中山装作陪，神采飞扬，丝毫不输给身边的总统。 02抗战爆发后，北平沦陷，清华师生穿越山河，与北大、南开共组西南联大。联大时期，陈岱孙先生的翩翩风度，更是让学校的女学生为之痴迷。陈岱孙擅长足球、网球、游泳、狩猎、高尔夫、曾在报纸上发表狩猎游记，一套高尔夫球杆收藏了60年。彼时，联大网球场上常有金岳霖、陈岱孙、赵乃博、浦薛凤四位老师的身影，其中最惹人注目的便是陈岱孙，他个头高，弹速快，频频上网拦击制胜。此外，他还喜欢听歌剧、昆曲，为学生组织“古音曲社”，亲自粉墨登场。闲来无事，他也好与人打斗智的桥牌，联大之中，鲜有敌手。这样一位近乎完美的老师，自然成了女学生们追慕的对象，当时联大里流传一句话：“以后恋爱，必须要比着陈先生的模子找。” 因其仪表非凡，教室前几排几乎坐满了女生。课堂上的先生魅力更是惊人：第一是时间概念精准。先生每次讲课，总提前2分钟站在黑板前，上课铃一响，他便旁征博引地讲起来，偶尔穿插点幽默，逗得学生哈哈大笑，自己却还一本正经。他讲完最后一个字，正好下课，一个字都不多。有一次，他讲完课将粉笔搁下，拍拍手上的粉笔灰，满教室的学生都怔怔地望着他。他便问学生：“你们怎么还不走？”学生叽叽喳喳地说还没打铃，陈岱孙先生满脸自信道：“你们走吧，学校的铃声打错了。”果不其然，那天下课铃声迟了好几分钟。 第二便是讲义。先生讲课能精确到每个字的时间，也是因为讲义的底子太过深厚。当时在西南联大，只有两位教授，能把专深学科讲到通透圆润的地步，一节课讲下来，正好是一个闭环的章节，知识结构首尾相连，比教科书还要准确。其中一个是冯友兰，另一位就是陈岱孙。听陈先生讲课，听者只要肯认真记下笔记，听完就等于得到了一部专著。如若学生手头勤快一点，听一节课的内容记一次笔记，就等于抄下一部专著的一个章节。这是清华派的一个传统，他们将大量的精力放在课堂和讲义上，陈寅恪、金岳霖莫不如此，所以这几位大师一生的著作都不多。一堂课的讲义，他们甚至要花一生的时间不断完善。直到七八十岁，陈岱孙先生还在继续做这项工作。 第三则是先生讲课的实用性。他讲《财经学》，年终论文命题，便是《假如我是财经部长》，还有一次学年考试，要求学生，分析校外摆摊人、修鞋匠的经济成分，一切从实际出发，锻炼学生，融会贯通、学以致用的能力。经济学家平新乔于北大师从陈岱孙先生时，曾将自己的论文递给陈先生审阅，初稿写下来之后兴冲冲地拿给老先生看，两个星期后，老人家批下来，平新乔接过一看，黄色的竖行纸，二十多页批注，一共七千字。第二遍改了再送上去，又批改了六页，直到第三遍才通过。平新乔后来感慨道：“看了陈老师的东西，才知道什么是威严，什么叫知识就是力量。”在陈先生面前，学生的任何一点沾沾自喜，和偷懒都会显得无地自容。这份严于治学的精神，更是影响了无数人。 最后一点，是陈先生决不用英语授课。虽然自小英语娴熟，留洋多年。但先生生平痛恨用英文讲课或夹杂英文，认为这是殖民地心态，未能摆脱对西方的崇拜。当时在清华授课的人里面，只有他和陈达坚决不用英文。 03金岳霖曾在回忆录中说过这么一句话：“还是要承认有非常之能办事的知识分子，陈岱孙先生就是这样一位。”金岳霖之所以这么说，是因为抗战结束后，在恢复清华校园的工作上，陈岱孙贡献了不可磨灭的力量。１９４５年８月１５日，日本无条件投降，临时组建的西南联大也面临着各回各地的局面。然而抗战期间，清华校园被日军破坏得十分凄惨，当时半个中国都在搬家，交通工具匮乏，联大便决定在昆明多待一年，派人回清华、北大、南开各校整理校产。１１月７日的清华校务会上，陈岱孙成为校产保管委员会的主席。 日军侵华期间，清华惨状，令人目不忍视、耳不忍闻。日本特务机关将土木工程系图书、气象系图书、无数化学仪器、打字机、实验器材用卡车搬走。之后，军队更是强占了校舍，驻军超过三千人，他们在校内搭建临时医院，将体育场变成了马厩、伙房，把老师的校舍变成“慰安溜”，各种家具、仪器被随意变卖，拿不走的搬不动的，干脆砍了之后拿来烧柴。图书馆内藏书，四万多种被日伪单位瓜分，连钢制书架也被分得干干净净。根据后来梅贻琦核定、统计，粗估清华校产损失约法币4876869400元。实际损失更是不可拿金钱数目来衡量。更残忍的是，日本华北派遣军，竟在清华礼堂外举办军犬比赛，数十名中国战俘和平民，被活活咬死，血流成河，图书馆的后面的煤厂，也变成了焚烧尸体的炉子… 抗战胜利后，国民政府，制定收容办法，遣特派员收容财产，不少人趁机大发其财，到了收复区简直如同土匪。不少地方的百姓感叹道：“刚送走了日本鬼子，又来了一帮畜生！”当陈岱孙与同事回到满目疮痍的清华时，要面对的交涉对象竟不是日军，而是先他们一步接管了校园的国军。当时国军极其蛮横，封存一切物资。陈岱孙致电梅贻琦，三番两次交涉无果。非但如此，国军第五补给区，强占清华全部医疗器械、药品后，为了赖着不走，居然动议，将日军搭建的医院改为兵站医院。眼看西南联大的学生就要回来，陈岱孙只好四处奔走，将军方行径公布于众，大声疾呼：“甚盼其能本维护教育之旨即行迁让，不再延宕，否则不惟摧残教育，责有攸归，而军令不行，纪律何存？” 之后校舍修缮十分艰难，陈岱孙四处寻找施工单位，教育部的拨款杯水车薪，连添置基本设备的钱都不够。陈岱孙接收清华时，全校屋馆设施损坏高达７５％，学生、老师宿舍高达８０％。陈岱孙一周工作七天，事无巨细，从进料到验货亲力亲为，数月之间，竟然将清华园恢复了战前原貌。其中但凡能依旧物重做的，全部复原。图书馆阅览室里只留下一把椅子没被烧毁，他便命人按照原样先做了两百套，校内碉堡全部清除，道路渐次修复，复又种植花草。 随后，他又带人去旧货市场，将日本人盗卖的清华旧物一一购回。８月，师生从昆明大批返回，来到经历浩劫的清华园，面对故园如旧，草木芬芳，全部露出不可思议的表情。校务长潘光旦叹道：“九年噩梦，已成云烟，今日归来，恍若离家未久。”开学后，清华将国军遗留杂物，通过抽签分配给大家，陈岱孙只得到一条军毯作为纪念，从此垫在床下，相伴终身。先生行动之敏捷，办事之果断，校长梅贻琦每每谈起，都对其夸赞不绝。 04更为人称道敬仰的，乃是先生高尚的人格。先生性格温和，与世无争，和谁都能相处。早在联大时，教授之间也有龃龉发生，毕竟都是恃才傲物之人，彼此会瞧不顺眼。但陈岱孙和朱自清处得很好，先生还为此写了一付对联，上联是“小住为佳，得小住且小住”，下联是“如何是好，愿如何便如何”。后来回清华与一代物理学宗师叶企孙同住，亦是相交甚笃。 照理说，陈先生出生于簪缨世家，祖上属于大官僚阶级，母系又有清朝外交官，十年内乱该是容易受冲击的对象。正是因为先生一生平和，与人无争，那十年间居然没受到过于激烈的批判，旁人无非是给他戴了“资产阶级趣味”的帽子，连工宣队的人都尊称其“先生”，简直不可思议。70多岁时，他被下放到江西鲤鱼洲，本来先生已经做好了死的准备，结果临行前突然不用去了。随后他被安排到丰台庞各庄收割麦子，先生个子高，弯腰割一会儿腰就剧痛，但最终他还是忍受了过来。 那个时期过去后，人际关系仍旧紧张，人们内心的恩仇和对立尚未消失。先生却以博大的胸怀面对所有人，在“育人”领域起到了示范作用。当时人们心中对知识分子的轻慢犹存，一次先生出去排队买烟，别人提醒售货员：“这是著名教授陈岱孙先生，先卖给他吧。”售货员翻了个白眼，让老先生好好排队，先生顺从不语。 这件事第二天登上《参考消息》，一个学生见报，专门来找先生。先生看了呵呵一乐：“买烟还登个报！怪难看的！”学生又道歉说：“先生还记得我吗，以前我也批过先生。”先生摆摆手道：“有吗？我不记得了。”1976年，平新乔几度报考研究生皆遭到阻力，最后一次报考北大经济系，导师便是陈先生。平新乔当时战战兢兢，无比惶恐，陈先生对他说：“我自己年轻时，也做过很多傻事、错事，也说过不少傻话、错话，谁不犯错误？错了，知道了，改就是了，应该有再学习的机会。”孔子推行的“仁教德育”，在先生这里，得到了最好的体现。 先生与冯友兰，1973年，内乱，消瘦中国经济学领域两大泰斗，一个是北大校长马寅初，一个是陈岱孙。马什么话都敢说，作为一个经济学家，他一两年之内有好几百场讲演，讲演对象是工商界人士，陈岱孙先生一辈子老老实实做教师，只给全职学生讲课，从不对企业家演讲。碰到什么事儿，马寅初喜欢从经济学角度写文章，见诸报端，所以《马寅初全集》有十卷之多。陈先生一生专于讲义，直到晚年才写下专著。在政治思潮涌动时期，学术领域受到干扰，不少学者随风转蓬，昧着良心以谋个人富贵，陈先生屹立不动，整整二十年只字未写。难怪有人说：“先生写文章与不写文章，都彰显了一个真正爱国知识份子的人格。” 05先生出身贵族，才学过人，胸襟坦荡，无论治学、品格，皆是世人的楷模。然而令人诧异的是，如此风流韵极，居然孤独一生，从未婚娶。曾有传言说，陈岱孙单身，是因为和周培源一起看上了王蒂澂。后来周与王结为伉俪，岱老因此孤独终身，然而全是胡诌，并无依据可考。晚年岱老接受采访时说：“为什么没有结婚，一是因为没时间，二是因为爱情需要两情相悦。”家人也曾安排他去相亲，但岱老始终没能遇到令自己心动的对象。在他看来，不是随意牵手就能点燃一场爱情，不是随便一个女子便能将就半生，恩爱承欢。他将自己的热忱与心力都留在了讲台，实在腾不出更多的精力给个人。 虽然一个人过了一辈子，但先生生活自理能力极强，衣柜、箱子总是整整齐齐。先生虽出身贵族，生活上却极其简朴，常年素衣淡茶，一个手提箱用了半个世纪，住所里没有空调，出门都是赶公交车。要知道在30年代，陈先生为法学院院长，一个月工资400大洋，400大洋是什么概念？放在今日，就是一个月5万的月薪！但到了1995年，工资只有860元人民币，如此大的落差，先生却从不放在心上。一位学生被错“划右”，精神失常，来找先生求救，先生早就不记得他了，但每个月给他寄钱，一寄就是整整8年！这就是一代宗师的高洁之风，怎能不叫人仰止？ 直到先生晚年，学生前去家中拜访，发现他用的还是西南联大回来时，在地摊上买的旧家具。谈到金钱，作为经济学宗师，先生淡淡地说：“人不能没钱，钱是需要的，但做事情完全为了钱，抛弃理想和事业，那是很危险的。”他肯定钱应有的作用，但反对拜金。1994年，岱老给《教育艺术》杂志题词：“学不厌，智也；教不倦，仁也，二者其教育之本乎。” 自1928年起，先生辗转清华、西南联大，北大三校，历经70年的岁月沉浮，直到90岁还在教书，终其一生，丹心可鉴，高洁其行，高山其才，世间罕见，他一生未婚，将自己毕生之思想、灿烂之光热，全都留给了三尺讲台，门下弟子遍及全球，学术卓越者堪称大师，仁教德育之光，长存世间，照亮之辈，何止千万？遥想当年，日本人打进北京，梅贻琦临时委托他去长沙，准备接清华过去，开完校务会，先生竟然连家都没回，穿着一件夏天长袍就奔上了去往长沙的道路。如此坚定的意志和为教育而行的果敢之心，世间再无二者！穿过时光的重重迷雾，我们仿佛还能看到先生笃定的背影，为中国之教育，奔波在硝烟弥漫的大地上，其心中装的又何止一校？乃是整个愤愤将起的中华！ 061997年7月9日，先生因病住院，在家门口从容登车时，亲人劝他换一件衣服，先生笑微微道：“不必了，过两天就回来。”27日，先生悄然辞世…弥留之际，先生常说的事情只有两件，其一，威斯康辛大学和哈佛，联合颁发给他的那把小金钥匙，曾被人趁乱抄走，他想知道如今在谁的手里。其二，他念念不忘清华大学，死前最后一句话是：“这里是清华…” 转载 网易新闻]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>名人</tag>
        <tag>纪念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个博客]]></title>
    <url>%2F2017%2F08%2F21%2FHello%2F</url>
    <content type="text"><![CDATA[考虑了很多，由于个人还是太懒，个人网站关掉了，不准备维护，因为已经很久没写什么东西了，还有就是嫌麻烦，以后写的东西将全部展示在这个博客上面，算是汇总一下吧，总结和梳理一下遗漏的知识点，当做我的学习历程吧。 .box{border-radius: 4px;line-height: 100px;color:#FFF;text-align:center;font-size:16px;margin:0 auto;height: 100px;width: 200px;background: rgba(255, 20, 147, .85);position: relative;} .box span{border: 26px solid transparent;border-bottom-color: rgba(255, 20, 147, .85);border-top: 0;border-right:0 ;position: absolute;top: 0;left: 50%;margin: -26px 0 0 -13px;} hello myblog]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
